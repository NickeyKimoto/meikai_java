!SESSION 2024-04-19 09:39:48.640 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\workspace\meikai_java\.metadata\.bak_1.log
Created Time: 2024-04-19 10:00:22.069

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:22.069
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int 
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) = x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-19 10:00:22.076
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-19 10:00:22.077
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:24.140
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) = x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-19 10:00:24.140
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-19 10:00:24.141
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:24.218
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) = x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-19 10:00:24.219
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-19 10:00:24.219
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:27.614
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) = x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-19 10:00:27.614
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-19 10:00:27.614
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:27.693
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) = x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-19 10:00:27.694
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-19 10:00:27.695
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:28.523
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0;
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) = x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-19 10:00:28.523
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-19 10:00:28.523
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:28.597
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0;
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) = x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-19 10:00:28.597
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-19 10:00:28.597
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:31.497
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0;
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) = x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-19 10:00:31.498
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-19 10:00:31.498
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:31.760
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0;
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) = x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-19 10:00:31.760
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-19 10:00:31.760
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:32.998
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0;
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) + x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-19 10:00:32.999
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-19 10:00:32.999
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:37.153
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0;
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) + x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-19 10:00:37.154
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-19 10:00:37.154
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:40.063
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0;
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) + (x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-19 10:00:40.063
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-19 10:00:40.064
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:40.161
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0;
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) + (x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-19 10:00:40.162
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-19 10:00:40.162
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:42.577
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0;
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) + (x / (2 * binalin) * 2 * n
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-19 10:00:42.577
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-19 10:00:42.578
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:49.891
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0;
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) + (x / (2 * binalin) * 2 * n)
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-19 10:00:49.891
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-19 10:00:49.891
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-19 10:00:52.844
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_12 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	static int rRotate(int x, int n) {
		
		int binalin = 1;
		int a = 31;
		int kes = 0;
		
		// 2のべき乗を計算
		while (a != 0) {

			// シフトする分だけ2を掛ける
			binalin *= 2;
			// 掛ける回数を0までカウントダウンする
			a--;

		}
		
		(x << n) + (x / (2 * binalin) * 2 * n)
		
	}

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-19 10:00:52.845
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-19 10:00:52.845
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-04-22 11:06:46.457 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-04-22 11:58:26.674
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-22 15:29:20.901
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY mergedoc.encoding 2 0 2024-04-22 15:36:56.138
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap07/E_07_17.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-22 15:36:56.138
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap07/E_07_17.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-22 15:36:56.199
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap07/E_07_17.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-22 15:36:56.200
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap07/E_07_17.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-22 15:36:56.202
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap07/E_07_17.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-22 15:36:56.203
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap07/E_07_17.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-22 15:36:56.250
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap07/E_07_17.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-22 15:36:56.250
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap07/E_07_17.java' が存在しません。
!SESSION 2024-04-23 09:41:55.375 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.lsp4e 2 0 2024-04-23 10:28:11.970
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 2 2 2024-04-23 10:32:07.780
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-23 16:09:25.796
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-23 16:18:15.383
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-23 16:43:05.337
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-23 19:01:39.764
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-04-24 09:35:32.959 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-04-24 09:53:05.388
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-24 11:33:44.117
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-24 13:07:26.018
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-24 16:53:03.154
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_31 {

	static int absolute(int x) {

		if (x > 0) {

			return x;

		} else  (x < 0) {

			return -x;

		}

	}

	public static void main(String[] args) {

		// Scannerオブジェクトを生成
		Scanner standardInput = new Scanner(System.in);

		// 一つ目の整数値の入力を促す
		System.out.print("xの値：");
		// 入力された値を読み込む
		int firstVariable = standardInput.nextInt();
		
		System.out.print(absolute(firstVariable));

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-24 16:53:03.156
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-24 16:53:03.156
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-24 16:53:03.196
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_31 {

	static int absolute(int x) {

		if (x > 0) {

			return x;

		} else  (x < 0) {

			return -x;

		}

	}

	public static void main(String[] args) {

		// Scannerオブジェクトを生成
		Scanner standardInput = new Scanner(System.in);

		// 一つ目の整数値の入力を促す
		System.out.print("xの値：");
		// 入力された値を読み込む
		int firstVariable = standardInput.nextInt();
		
		System.out.print(absolute(firstVariable));

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-24 16:53:03.196
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-24 16:53:03.197
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-24 16:53:03.899
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_31 {

	static int absolute(int x) {

		if (x > 0) {

			return x;

		} else (x < 0) {

			return -x;

		}

	}

	public static void main(String[] args) {

		// Scannerオブジェクトを生成
		Scanner standardInput = new Scanner(System.in);

		// 一つ目の整数値の入力を促す
		System.out.print("xの値：");
		// 入力された値を読み込む
		int firstVariable = standardInput.nextInt();
		
		System.out.print(absolute(firstVariable));

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-24 16:53:03.899
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-24 16:53:03.899
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-24 16:53:03.983
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_31 {

	static int absolute(int x) {

		if (x > 0) {

			return x;

		} else (x < 0) {

			return -x;

		}

	}

	public static void main(String[] args) {

		// Scannerオブジェクトを生成
		Scanner standardInput = new Scanner(System.in);

		// 一つ目の整数値の入力を促す
		System.out.print("xの値：");
		// 入力された値を読み込む
		int firstVariable = standardInput.nextInt();
		
		System.out.print(absolute(firstVariable));

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-24 16:53:03.983
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-24 16:53:03.983
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-24 16:53:06.449
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_31 {

	static int absolute(int x) {

		if (x > 0) {

			return x;

		} else (x < 0) {

			return -x;

		}

	}

	public static void main(String[] args) {

		// Scannerオブジェクトを生成
		Scanner standardInput = new Scanner(System.in);

		// 一つ目の整数値の入力を促す
		System.out.print("xの値：");
		// 入力された値を読み込む
		int firstVariable = standardInput.nextInt();
		
		System.out.print(absolute(firstVariable));

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-24 16:53:06.449
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-24 16:53:06.450
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-24 16:53:10.743
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_31 {

	static int absolute(int x) {

		if (x > 0) {

			return x;

		} else (x < 0) {

			return -x;

		}

	}

	public static void main(String[] args) {

		// Scannerオブジェクトを生成
		Scanner standardInput = new Scanner(System.in);

		// 一つ目の整数値の入力を促す
		System.out.print("xの値：");
		// 入力された値を読み込む
		int firstVariable = standardInput.nextInt();
		
		System.out.print(absolute(firstVariable));

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.createAst(CleanUpPostSaveListener.java:596)
	at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.saved(CleanUpPostSaveListener.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$4.run(CompilationUnitDocumentProvider.java:1642)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.notifyPostSaveListeners(CompilationUnitDocumentProvider.java:1636)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1420)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$3.execute(CompilationUnitDocumentProvider.java:1495)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:133)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:764)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5001)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1263)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1317)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7167)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveablesList.lambda$2(SaveablesList.java:840)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:848)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:812)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3426)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-24 16:53:10.745
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.createAst(CleanUpPostSaveListener.java:596)
	at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.saved(CleanUpPostSaveListener.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$4.run(CompilationUnitDocumentProvider.java:1642)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.notifyPostSaveListeners(CompilationUnitDocumentProvider.java:1636)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1420)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$3.execute(CompilationUnitDocumentProvider.java:1495)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:133)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:764)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5001)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1263)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1317)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7167)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveablesList.lambda$2(SaveablesList.java:840)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:848)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:812)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3426)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.ui 4 10006 2024-04-24 16:53:10.746
!MESSAGE 保存パーティシパント 'org.eclipse.jdt.ui.postsavelistener.cleanup' で例外発生: java.lang.IllegalArgumentException
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.createAst(CleanUpPostSaveListener.java:596)
	at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.saved(CleanUpPostSaveListener.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$4.run(CompilationUnitDocumentProvider.java:1642)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.notifyPostSaveListeners(CompilationUnitDocumentProvider.java:1636)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1420)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$3.execute(CompilationUnitDocumentProvider.java:1495)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:133)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:764)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5001)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1263)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1317)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7167)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveablesList.lambda$2(SaveablesList.java:840)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:848)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:812)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3426)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-24 16:53:11.367
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap07;

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class E_07_31 {

	static int absolute(int x) {

		if (x > 0) {

			return x;

		} else (x < 0) {

			return -x;

		}

	}

	public static void main(String[] args) {

		// Scannerオブジェクトを生成
		Scanner standardInput = new Scanner(System.in);

		// 一つ目の整数値の入力を促す
		System.out.print("xの値：");
		// 入力された値を読み込む
		int firstVariable = standardInput.nextInt();
		
		System.out.print(absolute(firstVariable));

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-24 16:53:11.368
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-24 16:53:11.369
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-24 17:03:58.926
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-04-25 09:36:02.206 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.lsp4e 2 0 2024-04-25 09:48:30.423
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-25 10:23:29.978
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-25 10:26:31.467
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 2 2 2024-04-25 10:56:16.360
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-25 14:22:49.801
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-04-26 09:37:50.021 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-04-26 09:38:41.893
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY mergedoc.encoding 2 0 2024-04-26 09:54:27.063
!MESSAGE リソース '/test/src/MeikaiJava/List/Account2/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-26 09:54:27.064
!MESSAGE リソース '/test/src/MeikaiJava/List/Account2/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-26 09:54:27.070
!MESSAGE リソース '/test/src/MeikaiJava/List/Account2/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-26 09:54:27.070
!MESSAGE リソース '/test/src/MeikaiJava/List/Account2/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-26 09:54:27.104
!MESSAGE リソース '/test/src/MeikaiJava/List/Account2/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-26 09:54:27.105
!MESSAGE リソース '/test/src/MeikaiJava/List/Account2/AccountTester.java' が存在しません。

!ENTRY org.eclipse.lsp4e 2 0 2024-04-26 10:00:34.717
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-26 16:52:43.093
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-04-30 09:34:07.397 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-04-30 10:09:45.115
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-30 10:44:29.843
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY mergedoc.encoding 2 0 2024-04-30 10:55:02.512
!MESSAGE リソース '/test/src/MeikaiJava/List/car1/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 10:55:02.513
!MESSAGE リソース '/test/src/MeikaiJava/List/car1/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 10:55:02.515
!MESSAGE リソース '/test/src/MeikaiJava/List/car1/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 10:55:02.516
!MESSAGE リソース '/test/src/MeikaiJava/List/car1/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 10:55:02.516
!MESSAGE リソース '/test/src/MeikaiJava/List/car1/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 10:55:02.517
!MESSAGE リソース '/test/src/MeikaiJava/List/car1/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 10:55:02.519
!MESSAGE リソース '/test/src/MeikaiJava/List/car1/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 10:55:02.519
!MESSAGE リソース '/test/src/MeikaiJava/List/car1/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 10:55:02.552
!MESSAGE リソース '/test/src/MeikaiJava/List/car1/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 10:55:02.553
!MESSAGE リソース '/test/src/MeikaiJava/List/car1/CarTester.java' が存在しません。

!ENTRY org.eclipse.lsp4e 2 0 2024-04-30 10:59:45.945
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY mergedoc.encoding 2 0 2024-04-30 11:48:16.894
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/parson/PersonTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 11:48:16.895
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/parson/PersonTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 11:48:16.896
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/parson/PersonTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 11:48:16.897
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/parson/PersonTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 11:48:16.897
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/parson/PersonTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 11:48:16.898
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/parson/PersonTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 11:48:16.899
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/parson/PersonTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 11:48:16.900
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/parson/PersonTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 11:48:16.924
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/parson/PersonTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 11:48:16.925
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/parson/PersonTester.java' が存在しません。

!ENTRY org.eclipse.jdt.core 4 4 2024-04-30 14:18:56.044
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap08.parson;

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

/*
*クラス名：PersonTester2
*概要：クラスPersonを実行し、入力した人の名前・身長・体重を表示する
*作成者：N.Kimoto
*作成日：2024/04/30
*/

public class PersonTester2 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/

	static void inputRange(double inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextInt();

	}

	/*
	*関数名：main
	*概要：入力した人の名前・身長・体重を表示
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/

	public static void main(String[] args) {

		// 人物データの入力を促す
		System.out.println("人物のデータを入力せよ。");

		// 名前の入力を促す
		System.out.print("名前は：");
		// 入力された文字を読み込む
		String name = standardInput.next();
		// 身長の入力を促す
		System.out.print("身長は：");
		double height = standardInput.nextDouble();
		// 0か負の値が入力された場合
		 (height <= 0) {

			// 正の整数を入力させる
			inputRange(height);

		}

		System.out.print("体重は：");
		double weight = standardInput.nextDouble();
		// 0か負の値が入力された場合
		if (weight <= 0) {

			inputRange(weight);

		}

		Person myself = new Person(name, height, weight);

		myself.putSpec();
		System.out.println();

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-30 14:18:56.053
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-30 14:18:56.054
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-30 14:18:56.105
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap08.parson;

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

/*
*クラス名：PersonTester2
*概要：クラスPersonを実行し、入力した人の名前・身長・体重を表示する
*作成者：N.Kimoto
*作成日：2024/04/30
*/

public class PersonTester2 {

	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/

	static void inputRange(double inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextInt();

	}

	/*
	*関数名：main
	*概要：入力した人の名前・身長・体重を表示
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/

	public static void main(String[] args) {

		// 人物データの入力を促す
		System.out.println("人物のデータを入力せよ。");

		// 名前の入力を促す
		System.out.print("名前は：");
		// 入力された文字を読み込む
		String name = standardInput.next();
		// 身長の入力を促す
		System.out.print("身長は：");
		double height = standardInput.nextDouble();
		// 0か負の値が入力された場合
		 (height <= 0) {

			// 正の整数を入力させる
			inputRange(height);

		}

		System.out.print("体重は：");
		double weight = standardInput.nextDouble();
		// 0か負の値が入力された場合
		if (weight <= 0) {

			inputRange(weight);

		}

		Person myself = new Person(name, height, weight);

		myself.putSpec();
		System.out.println();

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-30 14:18:56.106
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-30 14:18:56.107
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY mergedoc.encoding 2 0 2024-04-30 14:31:23.011
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 14:31:23.011
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 14:31:23.012
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 14:31:23.013
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 14:31:23.014
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 14:31:23.015
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 14:31:23.016
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 14:31:23.017
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 14:31:23.055
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 14:31:23.056
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/car.java' が存在しません。

!ENTRY org.eclipse.lsp4e 2 0 2024-04-30 15:32:07.442
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-30 16:04:21.168
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:00.701
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/Car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:00.702
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/Car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:00.703
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/Car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:00.704
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/Car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:00.706
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/Car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:00.713
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/Car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:00.715
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/Car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:00.716
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/Car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:00.757
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/Car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:00.758
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/Car.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:25.022
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarPuls.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:25.023
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarPuls.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:25.023
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarPuls.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:25.024
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarPuls.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:25.024
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarPuls.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:25.025
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarPuls.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:25.026
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarPuls.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:25.027
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarPuls.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:25.065
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarPuls.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:25.066
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarPuls.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.738
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.739
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.781
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.781
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.783
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.783
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.784
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.785
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.787
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.788
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.820
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-04-30 16:32:54.821
!MESSAGE リソース '/test/src/MeikaiJava/Chap08/car2/CarTester.java' が存在しません。

!ENTRY org.eclipse.lsp4e 2 0 2024-04-30 17:20:44.856
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-04-30 18:05:19.894
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-30 18:26:24.270
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap08.car2;

//ランダム関数を利用できるようにする
import java.util.Random;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

/*
*クラス名：CarPlus
*概要：車の各データを管理し表示する
*作成者：N.Kimoto
*作成日：2024/04/30
*/

public class CarPlus {
	
	// ランダムクラスのインスタンスを生成
	static Random randomVariable = new Random();
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	// 名前を表すインスタンス変数を宣言
	private String name;
	// 自動車メーカーを表すインスタンス変数を宣言
	private String carManufacturer;
	// ナンバープレート番号を表すインスタンス変数を宣言
	private String plateNumber;
	// 車幅を表すインスタンス変数を宣言
	private int width;
	// 車高を表すインスタンス変数を宣言
	private int height;
	// 車長を表すインスタンス変数を宣言
	private int length;
	// 現在位置X座標を表すインスタンス変数を宣言
	private double x;
	// 現在位置Y座標を表すインスタンス変数を宣言
	private double y;
	// タンク容量を表すインスタンス変数を宣言
	private double tankCapacity;
	// 残り燃料を表すインスタンス変数を宣言
	private double fuel;
	// 燃費を表すインスタンス変数を宣言
	private double fuelEfficiency;
	

	/*
	*コンストラクタ名：CarPlus
	*概要：インスタンスの初期化
	*引数：名前(String型)、自動車メーカー名(String型)、プレートナンバー(String型)、車幅(int型)、車高(int型)、
	*車長(int型)、残り燃料(double型)、タンク容量(double型)、燃費(double型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	CarPlus(String name, String carManufacturer, String plateNumber, int width, int height, 
			int length, double tankCapacity, double fuel, double fuelEfficiency) {
		
		// 名前を表すインスタンス変数を初期化
		this.name = name;
		// 自動車メーカーを表すインスタンス変数を初期化
		this.carManufacturer = carManufacturer;
		// ナンバープレート番号を表すインスタンス変数を初期化
		this.plateNumber = plateNumber;
		// 車幅を表すインスタンス変数を初期化
		this.width = width;
		// 車高を表すインスタンス変数を初期化
		this.height = height;
		// 車長を表すインスタンス変数を初期化
		this.length = length;
		// タンク容量を表すインスタンス変数を初期化
		this.tankCapacity = tankCapacity;
		// 残り燃料を表すインスタンス変数を初期化
		this.fuel = fuel;
		// 燃費を表すインスタンス変数を初期化
		this.fuelEfficiency = fuelEfficiency;
		// 現在位置X,Y座標を表すインスタンス変数を初期化
		x = y = 0.0;
		
	}
	
	// メソッド
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/

	static void inputRange(double inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextInt();

	}
	
	/*
	*関数名：getX
	*概要：現在位置のX座標を取得する
	*引数：なし
	*戻り値：現在位置のX座標(double型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	double getX() {
		
		// 現在位置のX座標を返却
		return x;
		
	}
	
	/*
	*関数名：getY
	*概要：現在位置のX座標を取得する
	*引数：なし
	*戻り値：現在位置のY座標(double型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	double getY() {
		
		// 現在位置のY座標を返却
		return y;
		
	}
	
	/*
	*関数名：getFuel
	*概要：現在の残り燃料を取得する
	*引数：なし
	*戻り値：現在の残り燃料(double型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	double getFuel() {
		
		// 現在の残り燃料を返却
		return fuel;
		
	}
	
	/*
	*関数名：putSpec
	*概要：各ステートの表示
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	void putSpec() {
		
		System.out.println("名前：" + name);
		System.out.println("自動車メーカー名：" + carManufacturer);
		System.out.println("ナンバープレート：" + plateNumber);
		System.out.println("車幅：" + width + "mm");
		System.out.println("車高：" + height + "mm");
		System.out.println("車長：" + length + "mm");
		System.out.println("タンク容量：" + tankCapacity + "L");
		System.out.println("燃費：" + fuelEfficiency + "km/L");
		
	}
	
	/*
	*関数名：move
	*概要：車を指定した場所に移動させる
	*引数：x方向の移動距離(double型)、y方向の移動距離(double型)
	*戻り値：移動の可否(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	boolean move(double dx, double dy) {
		
		// 移動の可否を表す変数を宣言
		boolean judgmentMove = true;
		
		// 移動距離を三平方の定理を用いて求める
		double dist = Math.sqrt(dx * dx + dy * dy);
		
		// 移動距離に対して燃料が足りない場合
		if (dist / fuelEfficiency > fuel) {
			
			// 移動できないため変数をfalseにする
			judgmentMove = false;
			
		// 移動距離に対して燃料が足りる場合
		} else {
			
			// 移動距離の分だけ燃料を消費
			fuel -= dist / fuelEfficiency;
			// x方向の移動距離を加算
			x += dx;
			// y方向の移動距離を加算
			y += dy;

		}
		
		// 移動の可否を返却
		return judgmentMove;
		
	}
	
	/*
	*関数名：moveGasStation
	*概要：車を近くのランダムなガソリンスタンドに移動させる
	*引数：なし
	*戻り値：給油の有無(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	boolean moveGasStation() {
		
		// ガソリンスタンドまでのx方向の距離をランダムに決定
		double besideDistance = randomVariable.nextDouble(1.0);
		// ガソリンスタンドまでのy方向の距離をランダムに決定
		double verticalDistance = randomVariable.nextDouble(1.0);
		
		// ガソリンスタンドまでの移動距離を三平方の定理を用いて求める
		double distanceGasStation = Math.sqrt(verticalDistance * verticalDistance + besideDistance * besideDistance);
		
		// 移動距離の分だけ燃料を消費
		fuel -= distanceGasStation / fuelEfficiency;
		
		// 移動距離を表示
		System.out.println("ガソリンスタンドまでの移動距離：" + distanceGasStation + "km");
		// 消費燃料を表示
		System.out.println("ガソリン消費量：" + distanceGasStation / fuelEfficiency + "L");
		
		// x方向の移動距離を加算
		x += verticalDistance;
		// y方向の移動距離を加算
		y += besideDistance;
		
		// 給油の有無を初期化
		boolean JudgmentNumber = true;
		
		// 給油が必要かどうか尋ねる
		System.out.print("給油しますか[0…No / 1…Yes]：");
		// 入力された値を読み込む
		int inputNumber = standardInput.nextInt();
		 (inputNumber != 0 && inputNumber != 1)
		// 入力範囲内の値を入力させる
		inputRange(inputNumber);
		
		if (inputNumber == 0) {
			
			JudgmentNumber = false;
			
		} else if (inputNumber == 1) {
			
			JudgmentNumber = true;
			
		}
		
		return JudgmentNumber;
		
		
	}
	
	void supplyOil() {
		
		final int GASOLINE_COST = 190;
		
		double payPrice = (tankCapacity - fuel) * GASOLINE_COST;
		
		fuel = tankCapacity;
		
		System.out.println("満タンまで給油しました。");
		System.out.println("ガソリン代は" + (int)payPrice + "円です。");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-30 18:26:24.270
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-30 18:26:24.271
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-30 18:26:24.344
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap08.car2;

//ランダム関数を利用できるようにする
import java.util.Random;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

/*
*クラス名：CarPlus
*概要：車の各データを管理し表示する
*作成者：N.Kimoto
*作成日：2024/04/30
*/

public class CarPlus {
	
	// ランダムクラスのインスタンスを生成
	static Random randomVariable = new Random();
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);

	// 名前を表すインスタンス変数を宣言
	private String name;
	// 自動車メーカーを表すインスタンス変数を宣言
	private String carManufacturer;
	// ナンバープレート番号を表すインスタンス変数を宣言
	private String plateNumber;
	// 車幅を表すインスタンス変数を宣言
	private int width;
	// 車高を表すインスタンス変数を宣言
	private int height;
	// 車長を表すインスタンス変数を宣言
	private int length;
	// 現在位置X座標を表すインスタンス変数を宣言
	private double x;
	// 現在位置Y座標を表すインスタンス変数を宣言
	private double y;
	// タンク容量を表すインスタンス変数を宣言
	private double tankCapacity;
	// 残り燃料を表すインスタンス変数を宣言
	private double fuel;
	// 燃費を表すインスタンス変数を宣言
	private double fuelEfficiency;
	

	/*
	*コンストラクタ名：CarPlus
	*概要：インスタンスの初期化
	*引数：名前(String型)、自動車メーカー名(String型)、プレートナンバー(String型)、車幅(int型)、車高(int型)、
	*車長(int型)、残り燃料(double型)、タンク容量(double型)、燃費(double型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	CarPlus(String name, String carManufacturer, String plateNumber, int width, int height, 
			int length, double tankCapacity, double fuel, double fuelEfficiency) {
		
		// 名前を表すインスタンス変数を初期化
		this.name = name;
		// 自動車メーカーを表すインスタンス変数を初期化
		this.carManufacturer = carManufacturer;
		// ナンバープレート番号を表すインスタンス変数を初期化
		this.plateNumber = plateNumber;
		// 車幅を表すインスタンス変数を初期化
		this.width = width;
		// 車高を表すインスタンス変数を初期化
		this.height = height;
		// 車長を表すインスタンス変数を初期化
		this.length = length;
		// タンク容量を表すインスタンス変数を初期化
		this.tankCapacity = tankCapacity;
		// 残り燃料を表すインスタンス変数を初期化
		this.fuel = fuel;
		// 燃費を表すインスタンス変数を初期化
		this.fuelEfficiency = fuelEfficiency;
		// 現在位置X,Y座標を表すインスタンス変数を初期化
		x = y = 0.0;
		
	}
	
	// メソッド
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/

	static void inputRange(double inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextInt();

	}
	
	/*
	*関数名：getX
	*概要：現在位置のX座標を取得する
	*引数：なし
	*戻り値：現在位置のX座標(double型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	double getX() {
		
		// 現在位置のX座標を返却
		return x;
		
	}
	
	/*
	*関数名：getY
	*概要：現在位置のX座標を取得する
	*引数：なし
	*戻り値：現在位置のY座標(double型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	double getY() {
		
		// 現在位置のY座標を返却
		return y;
		
	}
	
	/*
	*関数名：getFuel
	*概要：現在の残り燃料を取得する
	*引数：なし
	*戻り値：現在の残り燃料(double型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	double getFuel() {
		
		// 現在の残り燃料を返却
		return fuel;
		
	}
	
	/*
	*関数名：putSpec
	*概要：各ステートの表示
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	void putSpec() {
		
		System.out.println("名前：" + name);
		System.out.println("自動車メーカー名：" + carManufacturer);
		System.out.println("ナンバープレート：" + plateNumber);
		System.out.println("車幅：" + width + "mm");
		System.out.println("車高：" + height + "mm");
		System.out.println("車長：" + length + "mm");
		System.out.println("タンク容量：" + tankCapacity + "L");
		System.out.println("燃費：" + fuelEfficiency + "km/L");
		
	}
	
	/*
	*関数名：move
	*概要：車を指定した場所に移動させる
	*引数：x方向の移動距離(double型)、y方向の移動距離(double型)
	*戻り値：移動の可否(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	boolean move(double dx, double dy) {
		
		// 移動の可否を表す変数を宣言
		boolean judgmentMove = true;
		
		// 移動距離を三平方の定理を用いて求める
		double dist = Math.sqrt(dx * dx + dy * dy);
		
		// 移動距離に対して燃料が足りない場合
		if (dist / fuelEfficiency > fuel) {
			
			// 移動できないため変数をfalseにする
			judgmentMove = false;
			
		// 移動距離に対して燃料が足りる場合
		} else {
			
			// 移動距離の分だけ燃料を消費
			fuel -= dist / fuelEfficiency;
			// x方向の移動距離を加算
			x += dx;
			// y方向の移動距離を加算
			y += dy;

		}
		
		// 移動の可否を返却
		return judgmentMove;
		
	}
	
	/*
	*関数名：moveGasStation
	*概要：車を近くのランダムなガソリンスタンドに移動させる
	*引数：なし
	*戻り値：給油の有無(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	boolean moveGasStation() {
		
		// ガソリンスタンドまでのx方向の距離をランダムに決定
		double besideDistance = randomVariable.nextDouble(1.0);
		// ガソリンスタンドまでのy方向の距離をランダムに決定
		double verticalDistance = randomVariable.nextDouble(1.0);
		
		// ガソリンスタンドまでの移動距離を三平方の定理を用いて求める
		double distanceGasStation = Math.sqrt(verticalDistance * verticalDistance + besideDistance * besideDistance);
		
		// 移動距離の分だけ燃料を消費
		fuel -= distanceGasStation / fuelEfficiency;
		
		// 移動距離を表示
		System.out.println("ガソリンスタンドまでの移動距離：" + distanceGasStation + "km");
		// 消費燃料を表示
		System.out.println("ガソリン消費量：" + distanceGasStation / fuelEfficiency + "L");
		
		// x方向の移動距離を加算
		x += verticalDistance;
		// y方向の移動距離を加算
		y += besideDistance;
		
		// 給油の有無を初期化
		boolean JudgmentNumber = true;
		
		// 給油が必要かどうか尋ねる
		System.out.print("給油しますか[0…No / 1…Yes]：");
		// 入力された値を読み込む
		int inputNumber = standardInput.nextInt();
		 (inputNumber != 0 && inputNumber != 1)
		// 入力範囲内の値を入力させる
		inputRange(inputNumber);
		
		if (inputNumber == 0) {
			
			JudgmentNumber = false;
			
		} else if (inputNumber == 1) {
			
			JudgmentNumber = true;
			
		}
		
		return JudgmentNumber;
		
		
	}
	
	void supplyOil() {
		
		final int GASOLINE_COST = 190;
		
		double payPrice = (tankCapacity - fuel) * GASOLINE_COST;
		
		fuel = tankCapacity;
		
		System.out.println("満タンまで給油しました。");
		System.out.println("ガソリン代は" + (int)payPrice + "円です。");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-30 18:26:24.345
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-30 18:26:24.346
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-05-01 09:42:22.134 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-01 15:16:48.541
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2024-05-02 09:38:23.382 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-02 10:00:18.985
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-02 11:45:06.075
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-02 14:27:01.402
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-02 15:41:56.705
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-05-07 09:39:35.462 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.lsp4e 2 0 2024-05-07 09:46:42.721
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-07 09:47:28.139
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-07 10:28:22.573
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap9.day3;

/*
*クラス名：CheckOperationDay
*概要：日付を年・月・日(曜日)で表し、比較したり表示したりする
*作成者：N.Kimoto
*作成日：2024/05/02
*/

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class CheckOperationDay {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値(int型)
	*戻り値：読み込んだ値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange(int inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}

	public static void main(String[] args) {
		
		// 月の値の最大値の定数を宣言
		final int MAXIMUM_MONTH = 12;
		// 日の値の最大値の定数を宣言
		final int MAXIMUM_DATE = 31;
		
		// 一つ目の日付を入力させる
		System.out.println("day1を入力せよ。");
		// 年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int firstYear = standardInput.nextInt();
		// 入力された値が0以下の場合
		 (firstYear <= 0) {
			
			// 正の整数値を入力させる
			inputRange(firstYear);
			
		}
		
		// 一つ目の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int firstMonth = standardInput.nextInt();
		// 入力された値が0有効範囲外の場合
		if (firstMonth <= 0 || firstMonth > MAXIMUM_MONTH) {
			
			// 有効範囲内の整数値を入力させる
			inputRange(firstMonth);
			
		}
		
		// 一つ目の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int firstDate = standardInput.nextInt();
		// 入力された値が0以下の場合
		if (firstDate <= 0 || firstDate > MAXIMUM_DATE) {
			
			// 有効範囲内の整数値を入力させる
			inputRange(firstDate);
			
		}
		
		// 読み込んだ値で一つ目の日付を初期化
		Day firstDay = new Day(firstYear, firstMonth, firstDate);
		// 一つ目の日付を表示
		System.out.println("day1 = " + firstDay);
		
		// コピーコンストラクタで一つ目の日付と同じ日付で二つ目の日付を初期化する
		Day secondDay = new Day(firstDay);
		// 二つ目の日付にコピーしたことを表示
		System.out.println("day2をday1と同じ日付として作りました。");
		// 二つ目の日付を表示
		System.out.println("day2 = " + secondDay);
		
		// 二つの日付を比較し、同じだった場合
		if (firstDay.equalTo(secondDay)) {
					
			// 二つの日付が等しいことを表示
			System.out.println("day1とday2は等しいです。");
			
		// 二つの日付を比較し、同じではなかった場合
		} else {
			
			// 二つの日付が等しくないことを表示
			System.out.println("day1とday2は等しくありません。");
			
		}
		
		// 全てのコンストラクタが多重定義されているか検証
		// 一つ目の日付を何も入力せずに初期化
		Day sampleFirstDay  = new Day();
		// 二つ目の日付を年だけ入力し初期化
		Day sampleSecondDay = new Day(firstYear);
		// 三つ目の日付を年と月だけ入力し初期化
		Day sampleThirdDay  = new Day(firstYear, firstMonth);
		// 四つ目の日付を年・月・日を入力し初期化
		Day sampleFourthDay = new Day(firstYear, firstMonth, firstDate);
		
		// 一つ目の日付を表示
		System.out.println("d1   = " + sampleFirstDay);
		// 二つ目の日付を表示
		System.out.println("d2   = " + sampleSecondDay);
		// 三つ目の日付を表示
		System.out.println("d3   = " + sampleThirdDay);
		// 四つ目の日付を表示
		System.out.println("d4   = " + sampleFourthDay);
		
		// Day型配列を生成することを表示
		System.out.println("day型の配列を生成します。");
		// 要素数の入力を促す
		System.out.print("要素数：");
		// 入力された値を読み込む
		int elementCount = standardInput.nextInt();
		// 入力された値が0以下の場合
		if (elementCount <= 0) {
			
			// 正の整数値を入力させる
			inputRange(elementCount);
			
		}
		
		// 入力された値の要素数を持つ日付のDay型配列を生成
		Day[] dateArray = new Day[elementCount];
		
		// 生成した配列の全要素に日付を初期化する
		for(int i = 0; i < dateArray.length; i++) {
			
			// 全要素を1年1月1日に設定
			dateArray[i] = new Day();
			
		}
		
		// 生成した配列の全要素の日付を表示
		for(int i = 0; i < dateArray.length; i++) {
			
			// 要素の日付を表示
			System.out.println("a[" + i + "] = " + dateArray[i]);
			
		}

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-05-07 10:28:22.574
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-05-07 10:28:22.582
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-07 10:28:22.677
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap9.day3;

/*
*クラス名：CheckOperationDay
*概要：日付を年・月・日(曜日)で表し、比較したり表示したりする
*作成者：N.Kimoto
*作成日：2024/05/02
*/

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class CheckOperationDay {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値(int型)
	*戻り値：読み込んだ値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange(int inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}

	public static void main(String[] args) {
		
		// 月の値の最大値の定数を宣言
		final int MAXIMUM_MONTH = 12;
		// 日の値の最大値の定数を宣言
		final int MAXIMUM_DATE = 31;
		
		// 一つ目の日付を入力させる
		System.out.println("day1を入力せよ。");
		// 年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int firstYear = standardInput.nextInt();
		// 入力された値が0以下の場合
		 (firstYear <= 0) {
			
			// 正の整数値を入力させる
			inputRange(firstYear);
			
		}
		
		// 一つ目の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int firstMonth = standardInput.nextInt();
		// 入力された値が0有効範囲外の場合
		if (firstMonth <= 0 || firstMonth > MAXIMUM_MONTH) {
			
			// 有効範囲内の整数値を入力させる
			inputRange(firstMonth);
			
		}
		
		// 一つ目の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int firstDate = standardInput.nextInt();
		// 入力された値が0以下の場合
		if (firstDate <= 0 || firstDate > MAXIMUM_DATE) {
			
			// 有効範囲内の整数値を入力させる
			inputRange(firstDate);
			
		}
		
		// 読み込んだ値で一つ目の日付を初期化
		Day firstDay = new Day(firstYear, firstMonth, firstDate);
		// 一つ目の日付を表示
		System.out.println("day1 = " + firstDay);
		
		// コピーコンストラクタで一つ目の日付と同じ日付で二つ目の日付を初期化する
		Day secondDay = new Day(firstDay);
		// 二つ目の日付にコピーしたことを表示
		System.out.println("day2をday1と同じ日付として作りました。");
		// 二つ目の日付を表示
		System.out.println("day2 = " + secondDay);
		
		// 二つの日付を比較し、同じだった場合
		if (firstDay.equalTo(secondDay)) {
					
			// 二つの日付が等しいことを表示
			System.out.println("day1とday2は等しいです。");
			
		// 二つの日付を比較し、同じではなかった場合
		} else {
			
			// 二つの日付が等しくないことを表示
			System.out.println("day1とday2は等しくありません。");
			
		}
		
		// 全てのコンストラクタが多重定義されているか検証
		// 一つ目の日付を何も入力せずに初期化
		Day sampleFirstDay  = new Day();
		// 二つ目の日付を年だけ入力し初期化
		Day sampleSecondDay = new Day(firstYear);
		// 三つ目の日付を年と月だけ入力し初期化
		Day sampleThirdDay  = new Day(firstYear, firstMonth);
		// 四つ目の日付を年・月・日を入力し初期化
		Day sampleFourthDay = new Day(firstYear, firstMonth, firstDate);
		
		// 一つ目の日付を表示
		System.out.println("d1   = " + sampleFirstDay);
		// 二つ目の日付を表示
		System.out.println("d2   = " + sampleSecondDay);
		// 三つ目の日付を表示
		System.out.println("d3   = " + sampleThirdDay);
		// 四つ目の日付を表示
		System.out.println("d4   = " + sampleFourthDay);
		
		// Day型配列を生成することを表示
		System.out.println("day型の配列を生成します。");
		// 要素数の入力を促す
		System.out.print("要素数：");
		// 入力された値を読み込む
		int elementCount = standardInput.nextInt();
		// 入力された値が0以下の場合
		if (elementCount <= 0) {
			
			// 正の整数値を入力させる
			inputRange(elementCount);
			
		}
		
		// 入力された値の要素数を持つ日付のDay型配列を生成
		Day[] dateArray = new Day[elementCount];
		
		// 生成した配列の全要素に日付を初期化する
		for(int i = 0; i < dateArray.length; i++) {
			
			// 全要素を1年1月1日に設定
			dateArray[i] = new Day();
			
		}
		
		// 生成した配列の全要素の日付を表示
		for(int i = 0; i < dateArray.length; i++) {
			
			// 要素の日付を表示
			System.out.println("a[" + i + "] = " + dateArray[i]);
			
		}

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-05-07 10:28:22.678
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-05-07 10:28:22.679
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-07 10:28:24.655
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap9.day3;

/*
*クラス名：CheckOperationDay
*概要：日付を年・月・日(曜日)で表し、比較したり表示したりする
*作成者：N.Kimoto
*作成日：2024/05/02
*/

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class CheckOperationDay {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値(int型)
	*戻り値：読み込んだ値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange(int inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}

	public static void main(String[] args) {
		
		// 月の値の最大値の定数を宣言
		final int MAXIMUM_MONTH = 12;
		// 日の値の最大値の定数を宣言
		final int MAXIMUM_DATE = 31;
		
		// 一つ目の日付を入力させる
		System.out.println("day1を入力せよ。");
		// 年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int firstYear = standardInput.nextInt();
		// 入力された値が0以下の場合
		 (firstYear <= 0) {
			
			// 正の整数値を入力させる
			inputRange(firstYear);
			
		}
		
		// 一つ目の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int firstMonth = standardInput.nextInt();
		// 入力された値が0有効範囲外の場合
		if (firstMonth <= 0 || firstMonth > MAXIMUM_MONTH) {
			
			// 有効範囲内の整数値を入力させる
			inputRange(firstMonth);
			
		}
		
		// 一つ目の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int firstDate = standardInput.nextInt();
		// 入力された値が0以下の場合
		if (firstDate <= 0 || firstDate > MAXIMUM_DATE) {
			
			// 有効範囲内の整数値を入力させる
			inputRange(firstDate);
			
		}
		
		// 読み込んだ値で一つ目の日付を初期化
		Day firstDay = new Day(firstYear, firstMonth, firstDate);
		// 一つ目の日付を表示
		System.out.println("day1 = " + firstDay);
		
		// コピーコンストラクタで一つ目の日付と同じ日付で二つ目の日付を初期化する
		Day secondDay = new Day(firstDay);
		// 二つ目の日付にコピーしたことを表示
		System.out.println("day2をday1と同じ日付として作りました。");
		// 二つ目の日付を表示
		System.out.println("day2 = " + secondDay);
		
		// 二つの日付を比較し、同じだった場合
		if (firstDay.equalTo(secondDay)) {
					
			// 二つの日付が等しいことを表示
			System.out.println("day1とday2は等しいです。");
			
		// 二つの日付を比較し、同じではなかった場合
		} else {
			
			// 二つの日付が等しくないことを表示
			System.out.println("day1とday2は等しくありません。");
			
		}
		
		// 全てのコンストラクタが多重定義されているか検証
		// 一つ目の日付を何も入力せずに初期化
		Day sampleFirstDay  = new Day();
		// 二つ目の日付を年だけ入力し初期化
		Day sampleSecondDay = new Day(firstYear);
		// 三つ目の日付を年と月だけ入力し初期化
		Day sampleThirdDay  = new Day(firstYear, firstMonth);
		// 四つ目の日付を年・月・日を入力し初期化
		Day sampleFourthDay = new Day(firstYear, firstMonth, firstDate);
		
		// 一つ目の日付を表示
		System.out.println("d1   = " + sampleFirstDay);
		// 二つ目の日付を表示
		System.out.println("d2   = " + sampleSecondDay);
		// 三つ目の日付を表示
		System.out.println("d3   = " + sampleThirdDay);
		// 四つ目の日付を表示
		System.out.println("d4   = " + sampleFourthDay);
		
		// Day型配列を生成することを表示
		System.out.println("day型の配列を生成します。");
		// 要素数の入力を促す
		System.out.print("要素数：");
		// 入力された値を読み込む
		int elementCount = standardInput.nextInt();
		// 入力された値が0以下の場合
		if (elementCount <= 0) {
			
			// 正の整数値を入力させる
			inputRange(elementCount);
			
		}
		
		// 入力された値の要素数を持つ日付のDay型配列を生成
		Day[] dateArray = new Day[elementCount];
		
		// 生成した配列の全要素に日付を初期化する
		for(int i = 0; i < dateArray.length; i++) {
			
			// 全要素を1年1月1日に設定
			dateArray[i] = new Day();
			
		}
		
		// 生成した配列の全要素の日付を表示
		for(int i = 0; i < dateArray.length; i++) {
			
			// 要素の日付を表示
			System.out.println("a[" + i + "] = " + dateArray[i]);
			
		}

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-05-07 10:28:24.655
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-05-07 10:28:24.655
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-07 10:28:24.734
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap9.day3;

/*
*クラス名：CheckOperationDay
*概要：日付を年・月・日(曜日)で表し、比較したり表示したりする
*作成者：N.Kimoto
*作成日：2024/05/02
*/

//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class CheckOperationDay {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値(int型)
	*戻り値：読み込んだ値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange(int inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}

	public static void main(String[] args) {
		
		// 月の値の最大値の定数を宣言
		final int MAXIMUM_MONTH = 12;
		// 日の値の最大値の定数を宣言
		final int MAXIMUM_DATE = 31;
		
		// 一つ目の日付を入力させる
		System.out.println("day1を入力せよ。");
		// 年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int firstYear = standardInput.nextInt();
		// 入力された値が0以下の場合
		 (firstYear <= 0) {
			
			// 正の整数値を入力させる
			inputRange(firstYear);
			
		}
		
		// 一つ目の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int firstMonth = standardInput.nextInt();
		// 入力された値が0有効範囲外の場合
		if (firstMonth <= 0 || firstMonth > MAXIMUM_MONTH) {
			
			// 有効範囲内の整数値を入力させる
			inputRange(firstMonth);
			
		}
		
		// 一つ目の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int firstDate = standardInput.nextInt();
		// 入力された値が0以下の場合
		if (firstDate <= 0 || firstDate > MAXIMUM_DATE) {
			
			// 有効範囲内の整数値を入力させる
			inputRange(firstDate);
			
		}
		
		// 読み込んだ値で一つ目の日付を初期化
		Day firstDay = new Day(firstYear, firstMonth, firstDate);
		// 一つ目の日付を表示
		System.out.println("day1 = " + firstDay);
		
		// コピーコンストラクタで一つ目の日付と同じ日付で二つ目の日付を初期化する
		Day secondDay = new Day(firstDay);
		// 二つ目の日付にコピーしたことを表示
		System.out.println("day2をday1と同じ日付として作りました。");
		// 二つ目の日付を表示
		System.out.println("day2 = " + secondDay);
		
		// 二つの日付を比較し、同じだった場合
		if (firstDay.equalTo(secondDay)) {
					
			// 二つの日付が等しいことを表示
			System.out.println("day1とday2は等しいです。");
			
		// 二つの日付を比較し、同じではなかった場合
		} else {
			
			// 二つの日付が等しくないことを表示
			System.out.println("day1とday2は等しくありません。");
			
		}
		
		// 全てのコンストラクタが多重定義されているか検証
		// 一つ目の日付を何も入力せずに初期化
		Day sampleFirstDay  = new Day();
		// 二つ目の日付を年だけ入力し初期化
		Day sampleSecondDay = new Day(firstYear);
		// 三つ目の日付を年と月だけ入力し初期化
		Day sampleThirdDay  = new Day(firstYear, firstMonth);
		// 四つ目の日付を年・月・日を入力し初期化
		Day sampleFourthDay = new Day(firstYear, firstMonth, firstDate);
		
		// 一つ目の日付を表示
		System.out.println("d1   = " + sampleFirstDay);
		// 二つ目の日付を表示
		System.out.println("d2   = " + sampleSecondDay);
		// 三つ目の日付を表示
		System.out.println("d3   = " + sampleThirdDay);
		// 四つ目の日付を表示
		System.out.println("d4   = " + sampleFourthDay);
		
		// Day型配列を生成することを表示
		System.out.println("day型の配列を生成します。");
		// 要素数の入力を促す
		System.out.print("要素数：");
		// 入力された値を読み込む
		int elementCount = standardInput.nextInt();
		// 入力された値が0以下の場合
		if (elementCount <= 0) {
			
			// 正の整数値を入力させる
			inputRange(elementCount);
			
		}
		
		// 入力された値の要素数を持つ日付のDay型配列を生成
		Day[] dateArray = new Day[elementCount];
		
		// 生成した配列の全要素に日付を初期化する
		for(int i = 0; i < dateArray.length; i++) {
			
			// 全要素を1年1月1日に設定
			dateArray[i] = new Day();
			
		}
		
		// 生成した配列の全要素の日付を表示
		for(int i = 0; i < dateArray.length; i++) {
			
			// 要素の日付を表示
			System.out.println("a[" + i + "] = " + dateArray[i]);
			
		}

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-05-07 10:28:24.737
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-05-07 10:28:24.737
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui 2 2 2024-05-07 15:42:52.194
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-07 19:00:09.500
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-07 19:44:15.701
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-05-08 09:54:18.145 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-08 10:09:59.031
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-08 11:58:39.600
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-08 17:58:00.504
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-05-09 09:38:33.048 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-09 11:09:28.053
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-09 14:41:15.611
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:03.928
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/Id.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:03.929
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/Id.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:03.930
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/Id.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:03.931
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/Id.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:03.932
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/Id.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:03.933
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/Id.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:03.936
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/Id.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:03.938
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/Id.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:03.977
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/Id.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:03.977
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/Id.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:23.076
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/IdTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:23.077
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/IdTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:23.078
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/IdTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:23.078
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/IdTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:23.079
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/IdTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:23.080
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/IdTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:23.082
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/IdTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:23.083
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/IdTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:23.123
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/IdTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-09 14:53:23.124
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/id2/IdTester.java' が存在しません。

!ENTRY org.eclipse.lsp4e 2 0 2024-05-09 15:07:49.951
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-09 15:10:43.114
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-09 15:54:19.075
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-05-10 09:37:38.599 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-10 09:39:44.469
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2024-05-13 09:52:51.764 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-13 10:54:02.362
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-13 14:35:02.610
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-13 14:35:12.040
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-13 17:02:37.470
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-05-14 09:59:50.105 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-14 10:41:35.793
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY mergedoc.encoding 2 0 2024-05-14 11:03:17.962
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/day4/UpdatedDayTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-14 11:03:17.963
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/day4/UpdatedDayTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-14 11:03:18.091
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/day4/DayTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-14 11:03:18.091
!MESSAGE リソース '/test/src/MeikaiJava/Chap10/day4/DayTester.java' が存在しません。

!ENTRY org.eclipse.lsp4e 2 0 2024-05-14 16:05:15.935
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-14 19:39:55.270
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-05-15 09:34:17.104 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.lsp4e 2 0 2024-05-15 09:49:06.727
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-15 10:10:49.947
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-15 10:20:41.671
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-15 10:24:43.513
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.ui 4 10001 2024-05-15 13:04:24.047
!MESSAGE 内部エラー
!STACK 0
org.eclipse.jface.text.BadLocationException
	at org.eclipse.jface.text.AbstractDocument.getChar(AbstractDocument.java:783)
	at org.eclipse.core.internal.filebuffers.SynchronizableDocument.getChar(SynchronizableDocument.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getBracketHoverInfo(JavaSourceHover.java:177)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo(JavaSourceHover.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo2(JavaSourceHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-15 13:28:45.865
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-15 13:51:43.909
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-15 14:49:02.876
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap10.day4;

import static java.util.Calendar.*;

import java.util.GregorianCalendar;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class Day {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	// 年の値を1に初期化するための定数を宣言
	static final int DEFAULT_YEAR = 1;
	// 月の値を1に初期化するための定数を宣言
	static final int DEFAULT_MONTH = 1;
	// 日の値を1に初期化するための定数を宣言
	static final int DEFAULT_DATE = 1;
	// 1月を表す定数を宣言
	static final int MONTH_JANUARY = 1;
	// 2月を表す定数を宣言
	static final int MONTH_FEBRUARY = 2;
	// 12カ月分ずらすための定数を宣言
	// うるう年によって起こる曜日のずれを計算しやすいように最終月にしたいため
	static final int SHIFT_MONTHS = 12;
	// ある日付の七日後や七日前は同じ曜日になるため、七日を表す定数を宣言
	static final int SAME_DAY_OF_THE_WEEK = 7;
	// get(MONTH)の返却する値を正しい月に調整する定数を宣言
	static final int ADJUST_MONTH_NOTATION = 1;
	// うるう年が発生する条件を配列に格納し宣言
	static final int[] CONDITIONS_CONSTANT_LEAP_YEAR = {4, 100, 400};
	// 年を表す値の最小値の定数を宣言
	static final int MINIMUM_YEAR = 1;
	// 月を表す値の最大値の定数を宣言
	static final int MAXIMUM_MONTH = 12;
	// 月を表す値の最小値の定数を宣言
	static final int MINIMUM_MONTH = 1;
	// 日を表す値の最小値の定数を宣言
	static final int MINIMUM_DATE = 1;
	
	// 年を表すインスタンス変数を宣言
	private int year = DEFAULT_YEAR;
	// 月を表すインスタンス変数を宣言
	private int month = DEFAULT_MONTH;
	// 日を表すインスタンス変数を宣言
	private int date = DEFAULT_DATE;
	
	// クラスメソッド(静的メソッド)
	//-- y年は閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：年(int型)
	*戻り値：閏年であるかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public static boolean isLeap(int applicableYear) {
		
		// ツェラーの公式を用いて指定された年と条件を照らし合わせ、閏年であるかどうかを返却する(教本準拠の式)
		return applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[0] == 0 && applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[1] 
				!= 0 || applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[2] == 0;
		
	}
	
	// コンストラクタ
	// コンストラクタを多重定義
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day() {
		
		// プログラム実行時の日付を取得
		GregorianCalendar today = new GregorianCalendar();
		
		// 年を表すインスタンス変数をプログラム実行時の日付で初期化
		this.year = today.get(YEAR);
		// 月を表すインスタンス変数をプログラム実行時の日付で初期化
		this.month = today.get(MONTH) + ADJUST_MONTH_NOTATION;
		// 日を表すインスタンス変数をプログラム実行時の日付で初期化
		this.date = today.get(DATE);
		
	}
	

	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public Day(int year) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month, int date) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
		// 受け取った日の引数が日の値の最小値を下回る場合
		if (date < MINIMUM_DATE) {
			
			// 日の値を1に調整
			date = MINIMUM_DATE;
			
		// 受け取った日の引数が日の値の最大値を上回る場合
		} else if (date > findMaximumDaysOfMonth(year, month)) {
			
			// 日の値をその月の最大日数に調整
			date = findMaximumDaysOfMonth(year, month);
			
		}
		// 日を表すインスタンス変数を引数で初期化
		this.date = date;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(Day d) {
		
		// 日付のそれぞれの値を表すインスタンス変数を引数の日付で初期化
		this(d.year, d.month, d.date);
		
	}
	
	// ゲッタ
	/*
	*関数名：getYear
	*概要：年を表すフィールドの値を取得
	*引数：なし
	*戻り値：年(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getYear() { 
		
		// 年を表すフィールドの値を返却
		return year;
		
	}
	
	/*
	*関数名：getMonth
	*概要：月を表すフィールドの値を取得
	*引数：なし
	*戻り値：月(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getMonth() { 
	
		// 月を表すフィールドの値を返却
		return month;
		
	}
	
	/*
	*関数名：getDate
	*概要：日を表すフィールドの値を取得
	*引数：なし
	*戻り値：日(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getDate() {
		
		// 日を表すフィールドの値を返却
		return date;
		
	}
	
	// セッタ
	/*
	*関数名：setYear
	*概要：フィールドに指定した年の値を設定
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setYear(int year) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		
	}
	
	/*
	*関数名：setMonth
	*概要：フィールドに指定した月の値を設定
	*引数：月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setMonth(int month) { 
		
		// フィールドに指定した月の値を設定
		this.month = month;
		
	}
	
	/*
	*関数名：setDate
	*概要：フィールドに指定した日の値を設定
	*引数：日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setDate(int date) {
		
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	/*
	*関数名：set
	*概要：フィールドに指定した日付の値を設定
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void set(int year, int month, int date) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		// フィールドに指定した月の値を設定
		this.month = month;
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	// インスタンスメソッド
	//-- 閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：なし
	*戻り値：その年が閏年かどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public boolean isLeap() {
		
		// 閏年の判定をメソッドを用いて行い、正否を返却する
		return isLeap(year);
		
	}
	
	/*
	*関数名：findMaximumDaysOfMonth
	*概要：指定した年の指定した月の最大日数を返却
	*引数：年(int型)、月(int型)
	*戻り値：最大日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int findMaximumDaysOfMonth (int inputYear, int inputMonth) {
		
		// その月の最大日数を格納した配列を宣言
		final int[] MAXIMUM_DAYS_OF_MONTH = {31, isLeap(inputYear)? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		// インデックス番号を引数の年と月に対応する箇所に調整し、最大日数を返却
		return MAXIMUM_DAYS_OF_MONTH[inputMonth - 1];
		
	}
	
	/*
	*関数名：day0fWeek
	*概要：その日付の曜日を求める
	*引数：日付(Day型)
	*戻り値：曜日表す値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int day0fWeek() {
		
		// 月による曜日のずれを求める公式の定数を構成要素に持つ配列を宣言
		final int[] SHIFT_IN_DAYS_OF_WEEK = {5, 8, 13};
		
		// 年を表す変数に指定した年の値を代入
		int y = year;    
		// 月を表す変数に指定した月の値を代入
		int m = month;

		// 日付が1月か2月だった場合、前年の13月14月として扱う
		if (m == MONTH_JANUARY || m == MONTH_FEBRUARY) {

			// 年の値を1減らす
			y--;
			// 月の値に12を加算する
			m += SHIFT_MONTHS;
			
		}
		
		// 曜日を求め、日曜日から土曜日までを0から6の値で返却
		return (y + y / CONDITIONS_CONSTANT_LEAP_YEAR[0] - y / CONDITIONS_CONSTANT_LEAP_YEAR[1] + y /
				CONDITIONS_CONSTANT_LEAP_YEAR[2] + (SHIFT_IN_DAYS_OF_WEEK[2] * m + 
						SHIFT_IN_DAYS_OF_WEEK[1]) / SHIFT_IN_DAYS_OF_WEEK[0] + date) % SAME_DAY_OF_THE_WEEK;
		
	}
	
	/*
	*関数名：equalTo
	*概要：指定した日付と比較し日付が等しいかどうかを判定する
	*引数：日付(Day型)
	*戻り値：等しいかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public boolean equalTo(Day d) {
		
		// 日付を比較しその正否を返却する
		return year == d.year && month == d.month && date == d.date;
		
	}
	
	/*
	*関数名：toString
	*概要：指定した日付を文字列で表現
	*引数：なし
	*戻り値：日付の文字列表現(String型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public String toString() {
		
		// 曜日を表す文字に初期化した配列を生成
		String[] wd = { "日", "月", "火", "水", "木", "金", "土" };
		
		// 日付を文字表現で返却
		return String.format("%04d年%02d月%02d日(%s)", year, month, date, wd[day0fWeek()]);
		
	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：calculateElapsedDays
	*概要：年内での経過日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での経過日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateElapsedDays(Day inputDay) {
		
		// 経過日数を正しい値に調整するための定数を宣言
		final int ADJUST_ELAPSED_DAYS = 1;
		
		// 経過日数を表す変数を宣言(初期値は日付の日の値までの日数)
		int elapsedDays = inputDay.date - ADJUST_ELAPSED_DAYS;
			
		// その月までの月の最大日数を経過日数に加算する
		for (int i = 1; i < inputDay.month; i++) {
			
			// その月の最大日数を経過日数に加算する
			elapsedDays += findMaximumDaysOfMonth(inputDay.year, i);
			
		}
		
		// 求めた経過日数を返却する
		return elapsedDays;
		
	}
	
	/*
	*関数名：calculateDaysLeft
	*概要：年内での残り日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での残り日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateDaysLeft(Day inputDay) {
		
		// 残り日数を正しい値に調整するための定数を宣言
		final int ADJUST_LEFT_DAYS = 1;
		// その年の最大日数を格納した配列を宣言する
		final int[] MAXIMUM_DAYS_OF_YEAR = {366, 365};
		// 閏年を考慮しながら残り日数を計算する
		int daysLeft = (inputDay.isLeap() ? MAXIMUM_DAYS_OF_YEAR[0] : MAXIMUM_DAYS_OF_YEAR[1])
				- calculateElapsedDays(inputDay) - ADJUST_LEFT_DAYS;
		
		// 求めた残り日数を返却する
		return daysLeft;
		
	}
	
	/*
	*関数名：calculateQuantifiedDate
	*概要：日付を比較可能な数値へと変更する
	*引数：日付(Day型)
	*戻り値：比較可能な数値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int calculateQuantifiedDate(Day inputDay) {
		
		// 日付を比較可能な数値へと変更した際に、最初の比較箇所となる部分を表す定数を宣言
		final int FIRST_COMPARISON_POINT = 10000;
		// 日付を比較可能な数値へと変更した際に、2番目の比較箇所となる部分を表す定数を宣言
		final int SECOND_COMPARISON_POINT = 100;
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = inputDay.getYear() * FIRST_COMPARISON_POINT +
				inputDay.getMonth() * SECOND_COMPARISON_POINT + inputDay.getDate();
		
		// 数値を返却
		return inputQuantifiedDate;
		
	}
	
	/*
	*関数名：compareOtherDates
	*概要：指定された日付と比較対象となる日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static void compareOtherDates (Day inputDay) {
		
		// 比較する対象となる日付の入力を促す
		System.out.println("比較する日付を入力せよ。");
		
		// 比較する対象となる日付の年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int targetsYear = standardInput.nextInt();
		// 比較する対象となる日付の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int targetsMonth = standardInput.nextInt();
		// 比較する対象となる日付の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int targetsDate = standardInput.nextInt();
		
		// 入力された値で比較する対象となる日付を初期化
		Day targetsDay = new Day(targetsYear, targetsMonth, targetsDate);
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = calculateQuantifiedDate(inputDay);
		// 比較する対象となる日付を計算し比較可能な数値へ変更
		int targetsQuantifiedDate = calculateQuantifiedDate(targetsDay);
		
		// 二つの日付を比較し、引数の日付のほうが大きい場合
		if (inputQuantifiedDate > targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも後の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも後の日付です。");
			
		// 二つの日付を比較し、引数の日付のほうが小さい場合
		} else if (inputQuantifiedDate < targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも前の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも前の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 引数の日付と対象の日付が同じ日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "と同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：compareTwoDates
	*概要：二つの日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void compareTwoDates (Day inputFirstDay, Day inputSecondDay) {
		
		// 引数の一つ目の日付を計算し比較可能な数値へ変更
		int inputFirstQuantifiedDate = calculateQuantifiedDate(inputFirstDay);
		// 引数の二つ目の日付を計算し比較可能な数値へ変更
		int inputSecondQuantifiedDate = calculateQuantifiedDate(inputSecondDay);
		
		// 二つの日付を比較し、一つ目の日付のほうが大きい場合
		if (inputFirstQuantifiedDate > inputSecondQuantifiedDate) {
			
			// 一つ目の日付が後の日付で二つ目の日付が前の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が後の日付で、" + inputSecondDay.toString() + "が前の日付です。");
			
		// 二つの日付を比較し、二つ目の日付のほうが大きい場合
		} else if (inputFirstQuantifiedDate < inputSecondQuantifiedDate) {
			
			// 一つ目の日付が前の日付で二つ目の日付が後の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が前の日付で、" + inputSecondDay.toString() + "が後の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 二つの日付が同じ日付であることを表示
			System.out.println(inputFirstDay.toString() + "と" + inputSecondDay.toString() + "は同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：calculateTomorrow
	*概要：引数の日付の次の日の日付を返却
	*引数：日付(Day型)
	*戻り値：次の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateTomorrow (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearTomorrow = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthTomorrow = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateTomorrow = inputDay.date;
		
		// 次の日の日付の日の値を1つ進める
		++dateTomorrow;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateTomorrow > findMaximumDaysOfMonth(yearTomorrow, monthTomorrow)) {
			
			// 次の日の日付の日の値を最小値に戻す
			dateTomorrow = MINIMUM_DATE;
			// 次の日の日付の月の値を1つ進める
			++monthTomorrow;
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthTomorrow > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthTomorrow = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearTomorrow;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearTomorrow, monthTomorrow, dateTomorrow);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：moveTomorrow
	*概要：引数の日付の次の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveTomorrow (Day inputDay) {
		
		// 引数の日付の次の日の日付を表示
		System.out.println("明日の日付：" + calculateTomorrow(inputDay).toString());
		
	}
	
	/*
	*関数名：calculateSeveralDaysLater
	*概要：引数の日付の数日後の日付を返却
	*引数：日付(Day型)
	*戻り値：数日後の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateSeveralDaysLater (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearSeveralDaysLater = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthSeveralDaysLater = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateSeveralDaysLater = inputDay.date;
		
		System.out.print("何日後(有効範囲…1日以上)：");
		int shiftNumberOfDays = standardInput.nextInt();
		while (shiftNumberOfDays <= 0) {
			
			shiftNumberOfDays = inputRange();
			
		}
		
		if (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date >= shiftNumberOfDays) {
			
			dateSeveralDaysLater += shiftNumberOfDays;
			
		} else {
			
			do {
				
				shiftNumberOfDays -= (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date);
				monthSeveralDaysLater++;
				
			} (shiftNumberOfDays >)
			
		}
		
		// 次の日の日付の日の値を1つ進める
		dateSeveralDaysLater += shiftNumberOfDays;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateSeveralDaysLater > findMaximumDaysOfMonth(yearSeveralDaysLater, monthSeveralDaysLater)) {
			
			// 次の日の日付の月の値を1つ進める
			++monthSeveralDaysLater;
			// 次の日の日付の日の値を最小値に戻す
			dateSeveralDaysLater = MINIMUM_DATE;

			
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthSeveralDaysLater > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthSeveralDaysLater = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearSeveralDaysLater;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearSeveralDaysLater, monthSeveralDaysLater, dateSeveralDaysLater);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：calculateYesterday
	*概要：引数の日付の前の日の日付を返却
	*引数：日付(Day型)
	*戻り値：前の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/

	public static Day calculateYesterday (Day inputDay) {
		
		// 前の日の日付の年の値を引数の日付の年の値で初期化
		int yearYesterday = inputDay.year;
		// 前の日の日付の月の値を引数の日付の月の値で初期化
		int monthYesterday = inputDay.month;
		// 前の日の日付の日の値を引数の日付の日の値で初期化
		int dateYesterday = inputDay.date;
		
		// 引数の日付の各値すべてがそれぞれの最小値だった場合
		if (inputDay.year == MINIMUM_YEAR && inputDay.month == MINIMUM_MONTH || inputDay.date == MINIMUM_DATE) {
			
			// これ以上前日に戻せないことを表示
			System.out.println("これ以上前日に戻せません。");
			
		// 引数の日付の各値がどれか一つでも最小値でなかった場合
		} else {
		
			// 前の日の日付の日の値を1つ戻す
			--dateYesterday;
			
			// 前の日の日付の日の値が最小値を下回る場合
			if (dateYesterday < MINIMUM_DATE) {
				
				// 前の日の日付の月の値を1つ戻す
				--monthYesterday;
				
				// 前の日の日付の月の値が最小値を下回る場合
				if (monthYesterday < MINIMUM_MONTH) {
					
					// 前の日の日付の年の値を1つ戻す
					--yearYesterday;
					// 前の日の日付の月の値を最大値に進める
					monthYesterday = MAXIMUM_MONTH;
					
				}
				
				// 前の日の日付の日の値をその月の最大日数に進める
				dateYesterday = findMaximumDaysOfMonth(yearYesterday, monthYesterday);
				
			}
			
		}
		
		// 前の日の日付を求めた値で初期化
		Day beforeDay = new Day(yearYesterday, monthYesterday, dateYesterday);
		
		// 前の日の日付を返却
		return beforeDay;
		
	}
	
	/*
	*関数名：moveYesterday
	*概要：引数の日付の前の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveYesterday (Day inputDay) {
		
		// 引数の日付の前の日の日付を表示
		System.out.println("昨日の日付：" + calculateYesterday(inputDay).toString());
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-05-15 14:49:02.877
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-05-15 14:49:02.885
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-15 14:49:03.889
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap10.day4;

import static java.util.Calendar.*;

import java.util.GregorianCalendar;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class Day {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	// 年の値を1に初期化するための定数を宣言
	static final int DEFAULT_YEAR = 1;
	// 月の値を1に初期化するための定数を宣言
	static final int DEFAULT_MONTH = 1;
	// 日の値を1に初期化するための定数を宣言
	static final int DEFAULT_DATE = 1;
	// 1月を表す定数を宣言
	static final int MONTH_JANUARY = 1;
	// 2月を表す定数を宣言
	static final int MONTH_FEBRUARY = 2;
	// 12カ月分ずらすための定数を宣言
	// うるう年によって起こる曜日のずれを計算しやすいように最終月にしたいため
	static final int SHIFT_MONTHS = 12;
	// ある日付の七日後や七日前は同じ曜日になるため、七日を表す定数を宣言
	static final int SAME_DAY_OF_THE_WEEK = 7;
	// get(MONTH)の返却する値を正しい月に調整する定数を宣言
	static final int ADJUST_MONTH_NOTATION = 1;
	// うるう年が発生する条件を配列に格納し宣言
	static final int[] CONDITIONS_CONSTANT_LEAP_YEAR = {4, 100, 400};
	// 年を表す値の最小値の定数を宣言
	static final int MINIMUM_YEAR = 1;
	// 月を表す値の最大値の定数を宣言
	static final int MAXIMUM_MONTH = 12;
	// 月を表す値の最小値の定数を宣言
	static final int MINIMUM_MONTH = 1;
	// 日を表す値の最小値の定数を宣言
	static final int MINIMUM_DATE = 1;
	
	// 年を表すインスタンス変数を宣言
	private int year = DEFAULT_YEAR;
	// 月を表すインスタンス変数を宣言
	private int month = DEFAULT_MONTH;
	// 日を表すインスタンス変数を宣言
	private int date = DEFAULT_DATE;
	
	// クラスメソッド(静的メソッド)
	//-- y年は閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：年(int型)
	*戻り値：閏年であるかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public static boolean isLeap(int applicableYear) {
		
		// ツェラーの公式を用いて指定された年と条件を照らし合わせ、閏年であるかどうかを返却する(教本準拠の式)
		return applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[0] == 0 && applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[1] 
				!= 0 || applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[2] == 0;
		
	}
	
	// コンストラクタ
	// コンストラクタを多重定義
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day() {
		
		// プログラム実行時の日付を取得
		GregorianCalendar today = new GregorianCalendar();
		
		// 年を表すインスタンス変数をプログラム実行時の日付で初期化
		this.year = today.get(YEAR);
		// 月を表すインスタンス変数をプログラム実行時の日付で初期化
		this.month = today.get(MONTH) + ADJUST_MONTH_NOTATION;
		// 日を表すインスタンス変数をプログラム実行時の日付で初期化
		this.date = today.get(DATE);
		
	}
	

	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public Day(int year) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month, int date) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
		// 受け取った日の引数が日の値の最小値を下回る場合
		if (date < MINIMUM_DATE) {
			
			// 日の値を1に調整
			date = MINIMUM_DATE;
			
		// 受け取った日の引数が日の値の最大値を上回る場合
		} else if (date > findMaximumDaysOfMonth(year, month)) {
			
			// 日の値をその月の最大日数に調整
			date = findMaximumDaysOfMonth(year, month);
			
		}
		// 日を表すインスタンス変数を引数で初期化
		this.date = date;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(Day d) {
		
		// 日付のそれぞれの値を表すインスタンス変数を引数の日付で初期化
		this(d.year, d.month, d.date);
		
	}
	
	// ゲッタ
	/*
	*関数名：getYear
	*概要：年を表すフィールドの値を取得
	*引数：なし
	*戻り値：年(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getYear() { 
		
		// 年を表すフィールドの値を返却
		return year;
		
	}
	
	/*
	*関数名：getMonth
	*概要：月を表すフィールドの値を取得
	*引数：なし
	*戻り値：月(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getMonth() { 
	
		// 月を表すフィールドの値を返却
		return month;
		
	}
	
	/*
	*関数名：getDate
	*概要：日を表すフィールドの値を取得
	*引数：なし
	*戻り値：日(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getDate() {
		
		// 日を表すフィールドの値を返却
		return date;
		
	}
	
	// セッタ
	/*
	*関数名：setYear
	*概要：フィールドに指定した年の値を設定
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setYear(int year) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		
	}
	
	/*
	*関数名：setMonth
	*概要：フィールドに指定した月の値を設定
	*引数：月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setMonth(int month) { 
		
		// フィールドに指定した月の値を設定
		this.month = month;
		
	}
	
	/*
	*関数名：setDate
	*概要：フィールドに指定した日の値を設定
	*引数：日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setDate(int date) {
		
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	/*
	*関数名：set
	*概要：フィールドに指定した日付の値を設定
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void set(int year, int month, int date) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		// フィールドに指定した月の値を設定
		this.month = month;
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	// インスタンスメソッド
	//-- 閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：なし
	*戻り値：その年が閏年かどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public boolean isLeap() {
		
		// 閏年の判定をメソッドを用いて行い、正否を返却する
		return isLeap(year);
		
	}
	
	/*
	*関数名：findMaximumDaysOfMonth
	*概要：指定した年の指定した月の最大日数を返却
	*引数：年(int型)、月(int型)
	*戻り値：最大日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int findMaximumDaysOfMonth (int inputYear, int inputMonth) {
		
		// その月の最大日数を格納した配列を宣言
		final int[] MAXIMUM_DAYS_OF_MONTH = {31, isLeap(inputYear)? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		// インデックス番号を引数の年と月に対応する箇所に調整し、最大日数を返却
		return MAXIMUM_DAYS_OF_MONTH[inputMonth - 1];
		
	}
	
	/*
	*関数名：day0fWeek
	*概要：その日付の曜日を求める
	*引数：日付(Day型)
	*戻り値：曜日表す値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int day0fWeek() {
		
		// 月による曜日のずれを求める公式の定数を構成要素に持つ配列を宣言
		final int[] SHIFT_IN_DAYS_OF_WEEK = {5, 8, 13};
		
		// 年を表す変数に指定した年の値を代入
		int y = year;    
		// 月を表す変数に指定した月の値を代入
		int m = month;

		// 日付が1月か2月だった場合、前年の13月14月として扱う
		if (m == MONTH_JANUARY || m == MONTH_FEBRUARY) {

			// 年の値を1減らす
			y--;
			// 月の値に12を加算する
			m += SHIFT_MONTHS;
			
		}
		
		// 曜日を求め、日曜日から土曜日までを0から6の値で返却
		return (y + y / CONDITIONS_CONSTANT_LEAP_YEAR[0] - y / CONDITIONS_CONSTANT_LEAP_YEAR[1] + y /
				CONDITIONS_CONSTANT_LEAP_YEAR[2] + (SHIFT_IN_DAYS_OF_WEEK[2] * m + 
						SHIFT_IN_DAYS_OF_WEEK[1]) / SHIFT_IN_DAYS_OF_WEEK[0] + date) % SAME_DAY_OF_THE_WEEK;
		
	}
	
	/*
	*関数名：equalTo
	*概要：指定した日付と比較し日付が等しいかどうかを判定する
	*引数：日付(Day型)
	*戻り値：等しいかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public boolean equalTo(Day d) {
		
		// 日付を比較しその正否を返却する
		return year == d.year && month == d.month && date == d.date;
		
	}
	
	/*
	*関数名：toString
	*概要：指定した日付を文字列で表現
	*引数：なし
	*戻り値：日付の文字列表現(String型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public String toString() {
		
		// 曜日を表す文字に初期化した配列を生成
		String[] wd = { "日", "月", "火", "水", "木", "金", "土" };
		
		// 日付を文字表現で返却
		return String.format("%04d年%02d月%02d日(%s)", year, month, date, wd[day0fWeek()]);
		
	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：calculateElapsedDays
	*概要：年内での経過日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での経過日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateElapsedDays(Day inputDay) {
		
		// 経過日数を正しい値に調整するための定数を宣言
		final int ADJUST_ELAPSED_DAYS = 1;
		
		// 経過日数を表す変数を宣言(初期値は日付の日の値までの日数)
		int elapsedDays = inputDay.date - ADJUST_ELAPSED_DAYS;
			
		// その月までの月の最大日数を経過日数に加算する
		for (int i = 1; i < inputDay.month; i++) {
			
			// その月の最大日数を経過日数に加算する
			elapsedDays += findMaximumDaysOfMonth(inputDay.year, i);
			
		}
		
		// 求めた経過日数を返却する
		return elapsedDays;
		
	}
	
	/*
	*関数名：calculateDaysLeft
	*概要：年内での残り日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での残り日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateDaysLeft(Day inputDay) {
		
		// 残り日数を正しい値に調整するための定数を宣言
		final int ADJUST_LEFT_DAYS = 1;
		// その年の最大日数を格納した配列を宣言する
		final int[] MAXIMUM_DAYS_OF_YEAR = {366, 365};
		// 閏年を考慮しながら残り日数を計算する
		int daysLeft = (inputDay.isLeap() ? MAXIMUM_DAYS_OF_YEAR[0] : MAXIMUM_DAYS_OF_YEAR[1])
				- calculateElapsedDays(inputDay) - ADJUST_LEFT_DAYS;
		
		// 求めた残り日数を返却する
		return daysLeft;
		
	}
	
	/*
	*関数名：calculateQuantifiedDate
	*概要：日付を比較可能な数値へと変更する
	*引数：日付(Day型)
	*戻り値：比較可能な数値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int calculateQuantifiedDate(Day inputDay) {
		
		// 日付を比較可能な数値へと変更した際に、最初の比較箇所となる部分を表す定数を宣言
		final int FIRST_COMPARISON_POINT = 10000;
		// 日付を比較可能な数値へと変更した際に、2番目の比較箇所となる部分を表す定数を宣言
		final int SECOND_COMPARISON_POINT = 100;
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = inputDay.getYear() * FIRST_COMPARISON_POINT +
				inputDay.getMonth() * SECOND_COMPARISON_POINT + inputDay.getDate();
		
		// 数値を返却
		return inputQuantifiedDate;
		
	}
	
	/*
	*関数名：compareOtherDates
	*概要：指定された日付と比較対象となる日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static void compareOtherDates (Day inputDay) {
		
		// 比較する対象となる日付の入力を促す
		System.out.println("比較する日付を入力せよ。");
		
		// 比較する対象となる日付の年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int targetsYear = standardInput.nextInt();
		// 比較する対象となる日付の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int targetsMonth = standardInput.nextInt();
		// 比較する対象となる日付の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int targetsDate = standardInput.nextInt();
		
		// 入力された値で比較する対象となる日付を初期化
		Day targetsDay = new Day(targetsYear, targetsMonth, targetsDate);
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = calculateQuantifiedDate(inputDay);
		// 比較する対象となる日付を計算し比較可能な数値へ変更
		int targetsQuantifiedDate = calculateQuantifiedDate(targetsDay);
		
		// 二つの日付を比較し、引数の日付のほうが大きい場合
		if (inputQuantifiedDate > targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも後の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも後の日付です。");
			
		// 二つの日付を比較し、引数の日付のほうが小さい場合
		} else if (inputQuantifiedDate < targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも前の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも前の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 引数の日付と対象の日付が同じ日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "と同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：compareTwoDates
	*概要：二つの日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void compareTwoDates (Day inputFirstDay, Day inputSecondDay) {
		
		// 引数の一つ目の日付を計算し比較可能な数値へ変更
		int inputFirstQuantifiedDate = calculateQuantifiedDate(inputFirstDay);
		// 引数の二つ目の日付を計算し比較可能な数値へ変更
		int inputSecondQuantifiedDate = calculateQuantifiedDate(inputSecondDay);
		
		// 二つの日付を比較し、一つ目の日付のほうが大きい場合
		if (inputFirstQuantifiedDate > inputSecondQuantifiedDate) {
			
			// 一つ目の日付が後の日付で二つ目の日付が前の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が後の日付で、" + inputSecondDay.toString() + "が前の日付です。");
			
		// 二つの日付を比較し、二つ目の日付のほうが大きい場合
		} else if (inputFirstQuantifiedDate < inputSecondQuantifiedDate) {
			
			// 一つ目の日付が前の日付で二つ目の日付が後の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が前の日付で、" + inputSecondDay.toString() + "が後の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 二つの日付が同じ日付であることを表示
			System.out.println(inputFirstDay.toString() + "と" + inputSecondDay.toString() + "は同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：calculateTomorrow
	*概要：引数の日付の次の日の日付を返却
	*引数：日付(Day型)
	*戻り値：次の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateTomorrow (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearTomorrow = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthTomorrow = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateTomorrow = inputDay.date;
		
		// 次の日の日付の日の値を1つ進める
		++dateTomorrow;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateTomorrow > findMaximumDaysOfMonth(yearTomorrow, monthTomorrow)) {
			
			// 次の日の日付の日の値を最小値に戻す
			dateTomorrow = MINIMUM_DATE;
			// 次の日の日付の月の値を1つ進める
			++monthTomorrow;
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthTomorrow > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthTomorrow = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearTomorrow;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearTomorrow, monthTomorrow, dateTomorrow);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：moveTomorrow
	*概要：引数の日付の次の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveTomorrow (Day inputDay) {
		
		// 引数の日付の次の日の日付を表示
		System.out.println("明日の日付：" + calculateTomorrow(inputDay).toString());
		
	}
	
	/*
	*関数名：calculateSeveralDaysLater
	*概要：引数の日付の数日後の日付を返却
	*引数：日付(Day型)
	*戻り値：数日後の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateSeveralDaysLater (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearSeveralDaysLater = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthSeveralDaysLater = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateSeveralDaysLater = inputDay.date;
		
		System.out.print("何日後(有効範囲…1日以上)：");
		int shiftNumberOfDays = standardInput.nextInt();
		while (shiftNumberOfDays <= 0) {
			
			shiftNumberOfDays = inputRange();
			
		}
		
		if (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date >= shiftNumberOfDays) {
			
			dateSeveralDaysLater += shiftNumberOfDays;
			
		} else {
			
			do {
				
				shiftNumberOfDays -= (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date);
				monthSeveralDaysLater++;
				
			} (shiftNumberOfDays > 0)
			
		}
		
		// 次の日の日付の日の値を1つ進める
		dateSeveralDaysLater += shiftNumberOfDays;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateSeveralDaysLater > findMaximumDaysOfMonth(yearSeveralDaysLater, monthSeveralDaysLater)) {
			
			// 次の日の日付の月の値を1つ進める
			++monthSeveralDaysLater;
			// 次の日の日付の日の値を最小値に戻す
			dateSeveralDaysLater = MINIMUM_DATE;

			
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthSeveralDaysLater > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthSeveralDaysLater = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearSeveralDaysLater;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearSeveralDaysLater, monthSeveralDaysLater, dateSeveralDaysLater);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：calculateYesterday
	*概要：引数の日付の前の日の日付を返却
	*引数：日付(Day型)
	*戻り値：前の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/

	public static Day calculateYesterday (Day inputDay) {
		
		// 前の日の日付の年の値を引数の日付の年の値で初期化
		int yearYesterday = inputDay.year;
		// 前の日の日付の月の値を引数の日付の月の値で初期化
		int monthYesterday = inputDay.month;
		// 前の日の日付の日の値を引数の日付の日の値で初期化
		int dateYesterday = inputDay.date;
		
		// 引数の日付の各値すべてがそれぞれの最小値だった場合
		if (inputDay.year == MINIMUM_YEAR && inputDay.month == MINIMUM_MONTH || inputDay.date == MINIMUM_DATE) {
			
			// これ以上前日に戻せないことを表示
			System.out.println("これ以上前日に戻せません。");
			
		// 引数の日付の各値がどれか一つでも最小値でなかった場合
		} else {
		
			// 前の日の日付の日の値を1つ戻す
			--dateYesterday;
			
			// 前の日の日付の日の値が最小値を下回る場合
			if (dateYesterday < MINIMUM_DATE) {
				
				// 前の日の日付の月の値を1つ戻す
				--monthYesterday;
				
				// 前の日の日付の月の値が最小値を下回る場合
				if (monthYesterday < MINIMUM_MONTH) {
					
					// 前の日の日付の年の値を1つ戻す
					--yearYesterday;
					// 前の日の日付の月の値を最大値に進める
					monthYesterday = MAXIMUM_MONTH;
					
				}
				
				// 前の日の日付の日の値をその月の最大日数に進める
				dateYesterday = findMaximumDaysOfMonth(yearYesterday, monthYesterday);
				
			}
			
		}
		
		// 前の日の日付を求めた値で初期化
		Day beforeDay = new Day(yearYesterday, monthYesterday, dateYesterday);
		
		// 前の日の日付を返却
		return beforeDay;
		
	}
	
	/*
	*関数名：moveYesterday
	*概要：引数の日付の前の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveYesterday (Day inputDay) {
		
		// 引数の日付の前の日の日付を表示
		System.out.println("昨日の日付：" + calculateYesterday(inputDay).toString());
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-05-15 14:49:03.890
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-05-15 14:49:03.891
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-15 14:49:03.996
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap10.day4;

import static java.util.Calendar.*;

import java.util.GregorianCalendar;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class Day {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	// 年の値を1に初期化するための定数を宣言
	static final int DEFAULT_YEAR = 1;
	// 月の値を1に初期化するための定数を宣言
	static final int DEFAULT_MONTH = 1;
	// 日の値を1に初期化するための定数を宣言
	static final int DEFAULT_DATE = 1;
	// 1月を表す定数を宣言
	static final int MONTH_JANUARY = 1;
	// 2月を表す定数を宣言
	static final int MONTH_FEBRUARY = 2;
	// 12カ月分ずらすための定数を宣言
	// うるう年によって起こる曜日のずれを計算しやすいように最終月にしたいため
	static final int SHIFT_MONTHS = 12;
	// ある日付の七日後や七日前は同じ曜日になるため、七日を表す定数を宣言
	static final int SAME_DAY_OF_THE_WEEK = 7;
	// get(MONTH)の返却する値を正しい月に調整する定数を宣言
	static final int ADJUST_MONTH_NOTATION = 1;
	// うるう年が発生する条件を配列に格納し宣言
	static final int[] CONDITIONS_CONSTANT_LEAP_YEAR = {4, 100, 400};
	// 年を表す値の最小値の定数を宣言
	static final int MINIMUM_YEAR = 1;
	// 月を表す値の最大値の定数を宣言
	static final int MAXIMUM_MONTH = 12;
	// 月を表す値の最小値の定数を宣言
	static final int MINIMUM_MONTH = 1;
	// 日を表す値の最小値の定数を宣言
	static final int MINIMUM_DATE = 1;
	
	// 年を表すインスタンス変数を宣言
	private int year = DEFAULT_YEAR;
	// 月を表すインスタンス変数を宣言
	private int month = DEFAULT_MONTH;
	// 日を表すインスタンス変数を宣言
	private int date = DEFAULT_DATE;
	
	// クラスメソッド(静的メソッド)
	//-- y年は閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：年(int型)
	*戻り値：閏年であるかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public static boolean isLeap(int applicableYear) {
		
		// ツェラーの公式を用いて指定された年と条件を照らし合わせ、閏年であるかどうかを返却する(教本準拠の式)
		return applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[0] == 0 && applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[1] 
				!= 0 || applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[2] == 0;
		
	}
	
	// コンストラクタ
	// コンストラクタを多重定義
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day() {
		
		// プログラム実行時の日付を取得
		GregorianCalendar today = new GregorianCalendar();
		
		// 年を表すインスタンス変数をプログラム実行時の日付で初期化
		this.year = today.get(YEAR);
		// 月を表すインスタンス変数をプログラム実行時の日付で初期化
		this.month = today.get(MONTH) + ADJUST_MONTH_NOTATION;
		// 日を表すインスタンス変数をプログラム実行時の日付で初期化
		this.date = today.get(DATE);
		
	}
	

	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public Day(int year) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month, int date) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
		// 受け取った日の引数が日の値の最小値を下回る場合
		if (date < MINIMUM_DATE) {
			
			// 日の値を1に調整
			date = MINIMUM_DATE;
			
		// 受け取った日の引数が日の値の最大値を上回る場合
		} else if (date > findMaximumDaysOfMonth(year, month)) {
			
			// 日の値をその月の最大日数に調整
			date = findMaximumDaysOfMonth(year, month);
			
		}
		// 日を表すインスタンス変数を引数で初期化
		this.date = date;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(Day d) {
		
		// 日付のそれぞれの値を表すインスタンス変数を引数の日付で初期化
		this(d.year, d.month, d.date);
		
	}
	
	// ゲッタ
	/*
	*関数名：getYear
	*概要：年を表すフィールドの値を取得
	*引数：なし
	*戻り値：年(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getYear() { 
		
		// 年を表すフィールドの値を返却
		return year;
		
	}
	
	/*
	*関数名：getMonth
	*概要：月を表すフィールドの値を取得
	*引数：なし
	*戻り値：月(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getMonth() { 
	
		// 月を表すフィールドの値を返却
		return month;
		
	}
	
	/*
	*関数名：getDate
	*概要：日を表すフィールドの値を取得
	*引数：なし
	*戻り値：日(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getDate() {
		
		// 日を表すフィールドの値を返却
		return date;
		
	}
	
	// セッタ
	/*
	*関数名：setYear
	*概要：フィールドに指定した年の値を設定
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setYear(int year) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		
	}
	
	/*
	*関数名：setMonth
	*概要：フィールドに指定した月の値を設定
	*引数：月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setMonth(int month) { 
		
		// フィールドに指定した月の値を設定
		this.month = month;
		
	}
	
	/*
	*関数名：setDate
	*概要：フィールドに指定した日の値を設定
	*引数：日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setDate(int date) {
		
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	/*
	*関数名：set
	*概要：フィールドに指定した日付の値を設定
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void set(int year, int month, int date) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		// フィールドに指定した月の値を設定
		this.month = month;
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	// インスタンスメソッド
	//-- 閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：なし
	*戻り値：その年が閏年かどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public boolean isLeap() {
		
		// 閏年の判定をメソッドを用いて行い、正否を返却する
		return isLeap(year);
		
	}
	
	/*
	*関数名：findMaximumDaysOfMonth
	*概要：指定した年の指定した月の最大日数を返却
	*引数：年(int型)、月(int型)
	*戻り値：最大日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int findMaximumDaysOfMonth (int inputYear, int inputMonth) {
		
		// その月の最大日数を格納した配列を宣言
		final int[] MAXIMUM_DAYS_OF_MONTH = {31, isLeap(inputYear)? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		// インデックス番号を引数の年と月に対応する箇所に調整し、最大日数を返却
		return MAXIMUM_DAYS_OF_MONTH[inputMonth - 1];
		
	}
	
	/*
	*関数名：day0fWeek
	*概要：その日付の曜日を求める
	*引数：日付(Day型)
	*戻り値：曜日表す値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int day0fWeek() {
		
		// 月による曜日のずれを求める公式の定数を構成要素に持つ配列を宣言
		final int[] SHIFT_IN_DAYS_OF_WEEK = {5, 8, 13};
		
		// 年を表す変数に指定した年の値を代入
		int y = year;    
		// 月を表す変数に指定した月の値を代入
		int m = month;

		// 日付が1月か2月だった場合、前年の13月14月として扱う
		if (m == MONTH_JANUARY || m == MONTH_FEBRUARY) {

			// 年の値を1減らす
			y--;
			// 月の値に12を加算する
			m += SHIFT_MONTHS;
			
		}
		
		// 曜日を求め、日曜日から土曜日までを0から6の値で返却
		return (y + y / CONDITIONS_CONSTANT_LEAP_YEAR[0] - y / CONDITIONS_CONSTANT_LEAP_YEAR[1] + y /
				CONDITIONS_CONSTANT_LEAP_YEAR[2] + (SHIFT_IN_DAYS_OF_WEEK[2] * m + 
						SHIFT_IN_DAYS_OF_WEEK[1]) / SHIFT_IN_DAYS_OF_WEEK[0] + date) % SAME_DAY_OF_THE_WEEK;
		
	}
	
	/*
	*関数名：equalTo
	*概要：指定した日付と比較し日付が等しいかどうかを判定する
	*引数：日付(Day型)
	*戻り値：等しいかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public boolean equalTo(Day d) {
		
		// 日付を比較しその正否を返却する
		return year == d.year && month == d.month && date == d.date;
		
	}
	
	/*
	*関数名：toString
	*概要：指定した日付を文字列で表現
	*引数：なし
	*戻り値：日付の文字列表現(String型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public String toString() {
		
		// 曜日を表す文字に初期化した配列を生成
		String[] wd = { "日", "月", "火", "水", "木", "金", "土" };
		
		// 日付を文字表現で返却
		return String.format("%04d年%02d月%02d日(%s)", year, month, date, wd[day0fWeek()]);
		
	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：calculateElapsedDays
	*概要：年内での経過日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での経過日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateElapsedDays(Day inputDay) {
		
		// 経過日数を正しい値に調整するための定数を宣言
		final int ADJUST_ELAPSED_DAYS = 1;
		
		// 経過日数を表す変数を宣言(初期値は日付の日の値までの日数)
		int elapsedDays = inputDay.date - ADJUST_ELAPSED_DAYS;
			
		// その月までの月の最大日数を経過日数に加算する
		for (int i = 1; i < inputDay.month; i++) {
			
			// その月の最大日数を経過日数に加算する
			elapsedDays += findMaximumDaysOfMonth(inputDay.year, i);
			
		}
		
		// 求めた経過日数を返却する
		return elapsedDays;
		
	}
	
	/*
	*関数名：calculateDaysLeft
	*概要：年内での残り日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での残り日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateDaysLeft(Day inputDay) {
		
		// 残り日数を正しい値に調整するための定数を宣言
		final int ADJUST_LEFT_DAYS = 1;
		// その年の最大日数を格納した配列を宣言する
		final int[] MAXIMUM_DAYS_OF_YEAR = {366, 365};
		// 閏年を考慮しながら残り日数を計算する
		int daysLeft = (inputDay.isLeap() ? MAXIMUM_DAYS_OF_YEAR[0] : MAXIMUM_DAYS_OF_YEAR[1])
				- calculateElapsedDays(inputDay) - ADJUST_LEFT_DAYS;
		
		// 求めた残り日数を返却する
		return daysLeft;
		
	}
	
	/*
	*関数名：calculateQuantifiedDate
	*概要：日付を比較可能な数値へと変更する
	*引数：日付(Day型)
	*戻り値：比較可能な数値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int calculateQuantifiedDate(Day inputDay) {
		
		// 日付を比較可能な数値へと変更した際に、最初の比較箇所となる部分を表す定数を宣言
		final int FIRST_COMPARISON_POINT = 10000;
		// 日付を比較可能な数値へと変更した際に、2番目の比較箇所となる部分を表す定数を宣言
		final int SECOND_COMPARISON_POINT = 100;
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = inputDay.getYear() * FIRST_COMPARISON_POINT +
				inputDay.getMonth() * SECOND_COMPARISON_POINT + inputDay.getDate();
		
		// 数値を返却
		return inputQuantifiedDate;
		
	}
	
	/*
	*関数名：compareOtherDates
	*概要：指定された日付と比較対象となる日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static void compareOtherDates (Day inputDay) {
		
		// 比較する対象となる日付の入力を促す
		System.out.println("比較する日付を入力せよ。");
		
		// 比較する対象となる日付の年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int targetsYear = standardInput.nextInt();
		// 比較する対象となる日付の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int targetsMonth = standardInput.nextInt();
		// 比較する対象となる日付の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int targetsDate = standardInput.nextInt();
		
		// 入力された値で比較する対象となる日付を初期化
		Day targetsDay = new Day(targetsYear, targetsMonth, targetsDate);
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = calculateQuantifiedDate(inputDay);
		// 比較する対象となる日付を計算し比較可能な数値へ変更
		int targetsQuantifiedDate = calculateQuantifiedDate(targetsDay);
		
		// 二つの日付を比較し、引数の日付のほうが大きい場合
		if (inputQuantifiedDate > targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも後の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも後の日付です。");
			
		// 二つの日付を比較し、引数の日付のほうが小さい場合
		} else if (inputQuantifiedDate < targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも前の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも前の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 引数の日付と対象の日付が同じ日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "と同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：compareTwoDates
	*概要：二つの日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void compareTwoDates (Day inputFirstDay, Day inputSecondDay) {
		
		// 引数の一つ目の日付を計算し比較可能な数値へ変更
		int inputFirstQuantifiedDate = calculateQuantifiedDate(inputFirstDay);
		// 引数の二つ目の日付を計算し比較可能な数値へ変更
		int inputSecondQuantifiedDate = calculateQuantifiedDate(inputSecondDay);
		
		// 二つの日付を比較し、一つ目の日付のほうが大きい場合
		if (inputFirstQuantifiedDate > inputSecondQuantifiedDate) {
			
			// 一つ目の日付が後の日付で二つ目の日付が前の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が後の日付で、" + inputSecondDay.toString() + "が前の日付です。");
			
		// 二つの日付を比較し、二つ目の日付のほうが大きい場合
		} else if (inputFirstQuantifiedDate < inputSecondQuantifiedDate) {
			
			// 一つ目の日付が前の日付で二つ目の日付が後の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が前の日付で、" + inputSecondDay.toString() + "が後の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 二つの日付が同じ日付であることを表示
			System.out.println(inputFirstDay.toString() + "と" + inputSecondDay.toString() + "は同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：calculateTomorrow
	*概要：引数の日付の次の日の日付を返却
	*引数：日付(Day型)
	*戻り値：次の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateTomorrow (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearTomorrow = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthTomorrow = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateTomorrow = inputDay.date;
		
		// 次の日の日付の日の値を1つ進める
		++dateTomorrow;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateTomorrow > findMaximumDaysOfMonth(yearTomorrow, monthTomorrow)) {
			
			// 次の日の日付の日の値を最小値に戻す
			dateTomorrow = MINIMUM_DATE;
			// 次の日の日付の月の値を1つ進める
			++monthTomorrow;
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthTomorrow > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthTomorrow = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearTomorrow;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearTomorrow, monthTomorrow, dateTomorrow);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：moveTomorrow
	*概要：引数の日付の次の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveTomorrow (Day inputDay) {
		
		// 引数の日付の次の日の日付を表示
		System.out.println("明日の日付：" + calculateTomorrow(inputDay).toString());
		
	}
	
	/*
	*関数名：calculateSeveralDaysLater
	*概要：引数の日付の数日後の日付を返却
	*引数：日付(Day型)
	*戻り値：数日後の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateSeveralDaysLater (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearSeveralDaysLater = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthSeveralDaysLater = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateSeveralDaysLater = inputDay.date;
		
		System.out.print("何日後(有効範囲…1日以上)：");
		int shiftNumberOfDays = standardInput.nextInt();
		while (shiftNumberOfDays <= 0) {
			
			shiftNumberOfDays = inputRange();
			
		}
		
		if (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date >= shiftNumberOfDays) {
			
			dateSeveralDaysLater += shiftNumberOfDays;
			
		} else {
			
			do {
				
				shiftNumberOfDays -= (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date);
				monthSeveralDaysLater++;
				
			} (shiftNumberOfDays > 0)
			
		}
		
		// 次の日の日付の日の値を1つ進める
		dateSeveralDaysLater += shiftNumberOfDays;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateSeveralDaysLater > findMaximumDaysOfMonth(yearSeveralDaysLater, monthSeveralDaysLater)) {
			
			// 次の日の日付の月の値を1つ進める
			++monthSeveralDaysLater;
			// 次の日の日付の日の値を最小値に戻す
			dateSeveralDaysLater = MINIMUM_DATE;

			
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthSeveralDaysLater > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthSeveralDaysLater = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearSeveralDaysLater;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearSeveralDaysLater, monthSeveralDaysLater, dateSeveralDaysLater);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：calculateYesterday
	*概要：引数の日付の前の日の日付を返却
	*引数：日付(Day型)
	*戻り値：前の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/

	public static Day calculateYesterday (Day inputDay) {
		
		// 前の日の日付の年の値を引数の日付の年の値で初期化
		int yearYesterday = inputDay.year;
		// 前の日の日付の月の値を引数の日付の月の値で初期化
		int monthYesterday = inputDay.month;
		// 前の日の日付の日の値を引数の日付の日の値で初期化
		int dateYesterday = inputDay.date;
		
		// 引数の日付の各値すべてがそれぞれの最小値だった場合
		if (inputDay.year == MINIMUM_YEAR && inputDay.month == MINIMUM_MONTH || inputDay.date == MINIMUM_DATE) {
			
			// これ以上前日に戻せないことを表示
			System.out.println("これ以上前日に戻せません。");
			
		// 引数の日付の各値がどれか一つでも最小値でなかった場合
		} else {
		
			// 前の日の日付の日の値を1つ戻す
			--dateYesterday;
			
			// 前の日の日付の日の値が最小値を下回る場合
			if (dateYesterday < MINIMUM_DATE) {
				
				// 前の日の日付の月の値を1つ戻す
				--monthYesterday;
				
				// 前の日の日付の月の値が最小値を下回る場合
				if (monthYesterday < MINIMUM_MONTH) {
					
					// 前の日の日付の年の値を1つ戻す
					--yearYesterday;
					// 前の日の日付の月の値を最大値に進める
					monthYesterday = MAXIMUM_MONTH;
					
				}
				
				// 前の日の日付の日の値をその月の最大日数に進める
				dateYesterday = findMaximumDaysOfMonth(yearYesterday, monthYesterday);
				
			}
			
		}
		
		// 前の日の日付を求めた値で初期化
		Day beforeDay = new Day(yearYesterday, monthYesterday, dateYesterday);
		
		// 前の日の日付を返却
		return beforeDay;
		
	}
	
	/*
	*関数名：moveYesterday
	*概要：引数の日付の前の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveYesterday (Day inputDay) {
		
		// 引数の日付の前の日の日付を表示
		System.out.println("昨日の日付：" + calculateYesterday(inputDay).toString());
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-05-15 14:49:03.999
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-05-15 14:49:04.000
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-15 14:49:09.644
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap10.day4;

import static java.util.Calendar.*;

import java.util.GregorianCalendar;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class Day {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	// 年の値を1に初期化するための定数を宣言
	static final int DEFAULT_YEAR = 1;
	// 月の値を1に初期化するための定数を宣言
	static final int DEFAULT_MONTH = 1;
	// 日の値を1に初期化するための定数を宣言
	static final int DEFAULT_DATE = 1;
	// 1月を表す定数を宣言
	static final int MONTH_JANUARY = 1;
	// 2月を表す定数を宣言
	static final int MONTH_FEBRUARY = 2;
	// 12カ月分ずらすための定数を宣言
	// うるう年によって起こる曜日のずれを計算しやすいように最終月にしたいため
	static final int SHIFT_MONTHS = 12;
	// ある日付の七日後や七日前は同じ曜日になるため、七日を表す定数を宣言
	static final int SAME_DAY_OF_THE_WEEK = 7;
	// get(MONTH)の返却する値を正しい月に調整する定数を宣言
	static final int ADJUST_MONTH_NOTATION = 1;
	// うるう年が発生する条件を配列に格納し宣言
	static final int[] CONDITIONS_CONSTANT_LEAP_YEAR = {4, 100, 400};
	// 年を表す値の最小値の定数を宣言
	static final int MINIMUM_YEAR = 1;
	// 月を表す値の最大値の定数を宣言
	static final int MAXIMUM_MONTH = 12;
	// 月を表す値の最小値の定数を宣言
	static final int MINIMUM_MONTH = 1;
	// 日を表す値の最小値の定数を宣言
	static final int MINIMUM_DATE = 1;
	
	// 年を表すインスタンス変数を宣言
	private int year = DEFAULT_YEAR;
	// 月を表すインスタンス変数を宣言
	private int month = DEFAULT_MONTH;
	// 日を表すインスタンス変数を宣言
	private int date = DEFAULT_DATE;
	
	// クラスメソッド(静的メソッド)
	//-- y年は閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：年(int型)
	*戻り値：閏年であるかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public static boolean isLeap(int applicableYear) {
		
		// ツェラーの公式を用いて指定された年と条件を照らし合わせ、閏年であるかどうかを返却する(教本準拠の式)
		return applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[0] == 0 && applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[1] 
				!= 0 || applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[2] == 0;
		
	}
	
	// コンストラクタ
	// コンストラクタを多重定義
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day() {
		
		// プログラム実行時の日付を取得
		GregorianCalendar today = new GregorianCalendar();
		
		// 年を表すインスタンス変数をプログラム実行時の日付で初期化
		this.year = today.get(YEAR);
		// 月を表すインスタンス変数をプログラム実行時の日付で初期化
		this.month = today.get(MONTH) + ADJUST_MONTH_NOTATION;
		// 日を表すインスタンス変数をプログラム実行時の日付で初期化
		this.date = today.get(DATE);
		
	}
	

	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public Day(int year) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month, int date) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
		// 受け取った日の引数が日の値の最小値を下回る場合
		if (date < MINIMUM_DATE) {
			
			// 日の値を1に調整
			date = MINIMUM_DATE;
			
		// 受け取った日の引数が日の値の最大値を上回る場合
		} else if (date > findMaximumDaysOfMonth(year, month)) {
			
			// 日の値をその月の最大日数に調整
			date = findMaximumDaysOfMonth(year, month);
			
		}
		// 日を表すインスタンス変数を引数で初期化
		this.date = date;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(Day d) {
		
		// 日付のそれぞれの値を表すインスタンス変数を引数の日付で初期化
		this(d.year, d.month, d.date);
		
	}
	
	// ゲッタ
	/*
	*関数名：getYear
	*概要：年を表すフィールドの値を取得
	*引数：なし
	*戻り値：年(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getYear() { 
		
		// 年を表すフィールドの値を返却
		return year;
		
	}
	
	/*
	*関数名：getMonth
	*概要：月を表すフィールドの値を取得
	*引数：なし
	*戻り値：月(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getMonth() { 
	
		// 月を表すフィールドの値を返却
		return month;
		
	}
	
	/*
	*関数名：getDate
	*概要：日を表すフィールドの値を取得
	*引数：なし
	*戻り値：日(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getDate() {
		
		// 日を表すフィールドの値を返却
		return date;
		
	}
	
	// セッタ
	/*
	*関数名：setYear
	*概要：フィールドに指定した年の値を設定
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setYear(int year) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		
	}
	
	/*
	*関数名：setMonth
	*概要：フィールドに指定した月の値を設定
	*引数：月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setMonth(int month) { 
		
		// フィールドに指定した月の値を設定
		this.month = month;
		
	}
	
	/*
	*関数名：setDate
	*概要：フィールドに指定した日の値を設定
	*引数：日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setDate(int date) {
		
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	/*
	*関数名：set
	*概要：フィールドに指定した日付の値を設定
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void set(int year, int month, int date) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		// フィールドに指定した月の値を設定
		this.month = month;
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	// インスタンスメソッド
	//-- 閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：なし
	*戻り値：その年が閏年かどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public boolean isLeap() {
		
		// 閏年の判定をメソッドを用いて行い、正否を返却する
		return isLeap(year);
		
	}
	
	/*
	*関数名：findMaximumDaysOfMonth
	*概要：指定した年の指定した月の最大日数を返却
	*引数：年(int型)、月(int型)
	*戻り値：最大日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int findMaximumDaysOfMonth (int inputYear, int inputMonth) {
		
		// その月の最大日数を格納した配列を宣言
		final int[] MAXIMUM_DAYS_OF_MONTH = {31, isLeap(inputYear)? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		// インデックス番号を引数の年と月に対応する箇所に調整し、最大日数を返却
		return MAXIMUM_DAYS_OF_MONTH[inputMonth - 1];
		
	}
	
	/*
	*関数名：day0fWeek
	*概要：その日付の曜日を求める
	*引数：日付(Day型)
	*戻り値：曜日表す値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int day0fWeek() {
		
		// 月による曜日のずれを求める公式の定数を構成要素に持つ配列を宣言
		final int[] SHIFT_IN_DAYS_OF_WEEK = {5, 8, 13};
		
		// 年を表す変数に指定した年の値を代入
		int y = year;    
		// 月を表す変数に指定した月の値を代入
		int m = month;

		// 日付が1月か2月だった場合、前年の13月14月として扱う
		if (m == MONTH_JANUARY || m == MONTH_FEBRUARY) {

			// 年の値を1減らす
			y--;
			// 月の値に12を加算する
			m += SHIFT_MONTHS;
			
		}
		
		// 曜日を求め、日曜日から土曜日までを0から6の値で返却
		return (y + y / CONDITIONS_CONSTANT_LEAP_YEAR[0] - y / CONDITIONS_CONSTANT_LEAP_YEAR[1] + y /
				CONDITIONS_CONSTANT_LEAP_YEAR[2] + (SHIFT_IN_DAYS_OF_WEEK[2] * m + 
						SHIFT_IN_DAYS_OF_WEEK[1]) / SHIFT_IN_DAYS_OF_WEEK[0] + date) % SAME_DAY_OF_THE_WEEK;
		
	}
	
	/*
	*関数名：equalTo
	*概要：指定した日付と比較し日付が等しいかどうかを判定する
	*引数：日付(Day型)
	*戻り値：等しいかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public boolean equalTo(Day d) {
		
		// 日付を比較しその正否を返却する
		return year == d.year && month == d.month && date == d.date;
		
	}
	
	/*
	*関数名：toString
	*概要：指定した日付を文字列で表現
	*引数：なし
	*戻り値：日付の文字列表現(String型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public String toString() {
		
		// 曜日を表す文字に初期化した配列を生成
		String[] wd = { "日", "月", "火", "水", "木", "金", "土" };
		
		// 日付を文字表現で返却
		return String.format("%04d年%02d月%02d日(%s)", year, month, date, wd[day0fWeek()]);
		
	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：calculateElapsedDays
	*概要：年内での経過日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での経過日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateElapsedDays(Day inputDay) {
		
		// 経過日数を正しい値に調整するための定数を宣言
		final int ADJUST_ELAPSED_DAYS = 1;
		
		// 経過日数を表す変数を宣言(初期値は日付の日の値までの日数)
		int elapsedDays = inputDay.date - ADJUST_ELAPSED_DAYS;
			
		// その月までの月の最大日数を経過日数に加算する
		for (int i = 1; i < inputDay.month; i++) {
			
			// その月の最大日数を経過日数に加算する
			elapsedDays += findMaximumDaysOfMonth(inputDay.year, i);
			
		}
		
		// 求めた経過日数を返却する
		return elapsedDays;
		
	}
	
	/*
	*関数名：calculateDaysLeft
	*概要：年内での残り日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での残り日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateDaysLeft(Day inputDay) {
		
		// 残り日数を正しい値に調整するための定数を宣言
		final int ADJUST_LEFT_DAYS = 1;
		// その年の最大日数を格納した配列を宣言する
		final int[] MAXIMUM_DAYS_OF_YEAR = {366, 365};
		// 閏年を考慮しながら残り日数を計算する
		int daysLeft = (inputDay.isLeap() ? MAXIMUM_DAYS_OF_YEAR[0] : MAXIMUM_DAYS_OF_YEAR[1])
				- calculateElapsedDays(inputDay) - ADJUST_LEFT_DAYS;
		
		// 求めた残り日数を返却する
		return daysLeft;
		
	}
	
	/*
	*関数名：calculateQuantifiedDate
	*概要：日付を比較可能な数値へと変更する
	*引数：日付(Day型)
	*戻り値：比較可能な数値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int calculateQuantifiedDate(Day inputDay) {
		
		// 日付を比較可能な数値へと変更した際に、最初の比較箇所となる部分を表す定数を宣言
		final int FIRST_COMPARISON_POINT = 10000;
		// 日付を比較可能な数値へと変更した際に、2番目の比較箇所となる部分を表す定数を宣言
		final int SECOND_COMPARISON_POINT = 100;
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = inputDay.getYear() * FIRST_COMPARISON_POINT +
				inputDay.getMonth() * SECOND_COMPARISON_POINT + inputDay.getDate();
		
		// 数値を返却
		return inputQuantifiedDate;
		
	}
	
	/*
	*関数名：compareOtherDates
	*概要：指定された日付と比較対象となる日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static void compareOtherDates (Day inputDay) {
		
		// 比較する対象となる日付の入力を促す
		System.out.println("比較する日付を入力せよ。");
		
		// 比較する対象となる日付の年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int targetsYear = standardInput.nextInt();
		// 比較する対象となる日付の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int targetsMonth = standardInput.nextInt();
		// 比較する対象となる日付の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int targetsDate = standardInput.nextInt();
		
		// 入力された値で比較する対象となる日付を初期化
		Day targetsDay = new Day(targetsYear, targetsMonth, targetsDate);
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = calculateQuantifiedDate(inputDay);
		// 比較する対象となる日付を計算し比較可能な数値へ変更
		int targetsQuantifiedDate = calculateQuantifiedDate(targetsDay);
		
		// 二つの日付を比較し、引数の日付のほうが大きい場合
		if (inputQuantifiedDate > targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも後の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも後の日付です。");
			
		// 二つの日付を比較し、引数の日付のほうが小さい場合
		} else if (inputQuantifiedDate < targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも前の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも前の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 引数の日付と対象の日付が同じ日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "と同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：compareTwoDates
	*概要：二つの日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void compareTwoDates (Day inputFirstDay, Day inputSecondDay) {
		
		// 引数の一つ目の日付を計算し比較可能な数値へ変更
		int inputFirstQuantifiedDate = calculateQuantifiedDate(inputFirstDay);
		// 引数の二つ目の日付を計算し比較可能な数値へ変更
		int inputSecondQuantifiedDate = calculateQuantifiedDate(inputSecondDay);
		
		// 二つの日付を比較し、一つ目の日付のほうが大きい場合
		if (inputFirstQuantifiedDate > inputSecondQuantifiedDate) {
			
			// 一つ目の日付が後の日付で二つ目の日付が前の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が後の日付で、" + inputSecondDay.toString() + "が前の日付です。");
			
		// 二つの日付を比較し、二つ目の日付のほうが大きい場合
		} else if (inputFirstQuantifiedDate < inputSecondQuantifiedDate) {
			
			// 一つ目の日付が前の日付で二つ目の日付が後の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が前の日付で、" + inputSecondDay.toString() + "が後の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 二つの日付が同じ日付であることを表示
			System.out.println(inputFirstDay.toString() + "と" + inputSecondDay.toString() + "は同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：calculateTomorrow
	*概要：引数の日付の次の日の日付を返却
	*引数：日付(Day型)
	*戻り値：次の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateTomorrow (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearTomorrow = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthTomorrow = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateTomorrow = inputDay.date;
		
		// 次の日の日付の日の値を1つ進める
		++dateTomorrow;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateTomorrow > findMaximumDaysOfMonth(yearTomorrow, monthTomorrow)) {
			
			// 次の日の日付の日の値を最小値に戻す
			dateTomorrow = MINIMUM_DATE;
			// 次の日の日付の月の値を1つ進める
			++monthTomorrow;
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthTomorrow > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthTomorrow = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearTomorrow;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearTomorrow, monthTomorrow, dateTomorrow);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：moveTomorrow
	*概要：引数の日付の次の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveTomorrow (Day inputDay) {
		
		// 引数の日付の次の日の日付を表示
		System.out.println("明日の日付：" + calculateTomorrow(inputDay).toString());
		
	}
	
	/*
	*関数名：calculateSeveralDaysLater
	*概要：引数の日付の数日後の日付を返却
	*引数：日付(Day型)
	*戻り値：数日後の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateSeveralDaysLater (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearSeveralDaysLater = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthSeveralDaysLater = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateSeveralDaysLater = inputDay.date;
		
		System.out.print("何日後(有効範囲…1日以上)：");
		int shiftNumberOfDays = standardInput.nextInt();
		while (shiftNumberOfDays <= 0) {
			
			shiftNumberOfDays = inputRange();
			
		}
		
		if (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date >= shiftNumberOfDays) {
			
			dateSeveralDaysLater += shiftNumberOfDays;
			
		} else {
			
			do {
				
				shiftNumberOfDays -= (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date);
				monthSeveralDaysLater++;
				
			} (shiftNumberOfDays < 0)
			
		}
		
		// 次の日の日付の日の値を1つ進める
		dateSeveralDaysLater += shiftNumberOfDays;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateSeveralDaysLater > findMaximumDaysOfMonth(yearSeveralDaysLater, monthSeveralDaysLater)) {
			
			// 次の日の日付の月の値を1つ進める
			++monthSeveralDaysLater;
			// 次の日の日付の日の値を最小値に戻す
			dateSeveralDaysLater = MINIMUM_DATE;

			
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthSeveralDaysLater > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthSeveralDaysLater = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearSeveralDaysLater;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearSeveralDaysLater, monthSeveralDaysLater, dateSeveralDaysLater);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：calculateYesterday
	*概要：引数の日付の前の日の日付を返却
	*引数：日付(Day型)
	*戻り値：前の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/

	public static Day calculateYesterday (Day inputDay) {
		
		// 前の日の日付の年の値を引数の日付の年の値で初期化
		int yearYesterday = inputDay.year;
		// 前の日の日付の月の値を引数の日付の月の値で初期化
		int monthYesterday = inputDay.month;
		// 前の日の日付の日の値を引数の日付の日の値で初期化
		int dateYesterday = inputDay.date;
		
		// 引数の日付の各値すべてがそれぞれの最小値だった場合
		if (inputDay.year == MINIMUM_YEAR && inputDay.month == MINIMUM_MONTH || inputDay.date == MINIMUM_DATE) {
			
			// これ以上前日に戻せないことを表示
			System.out.println("これ以上前日に戻せません。");
			
		// 引数の日付の各値がどれか一つでも最小値でなかった場合
		} else {
		
			// 前の日の日付の日の値を1つ戻す
			--dateYesterday;
			
			// 前の日の日付の日の値が最小値を下回る場合
			if (dateYesterday < MINIMUM_DATE) {
				
				// 前の日の日付の月の値を1つ戻す
				--monthYesterday;
				
				// 前の日の日付の月の値が最小値を下回る場合
				if (monthYesterday < MINIMUM_MONTH) {
					
					// 前の日の日付の年の値を1つ戻す
					--yearYesterday;
					// 前の日の日付の月の値を最大値に進める
					monthYesterday = MAXIMUM_MONTH;
					
				}
				
				// 前の日の日付の日の値をその月の最大日数に進める
				dateYesterday = findMaximumDaysOfMonth(yearYesterday, monthYesterday);
				
			}
			
		}
		
		// 前の日の日付を求めた値で初期化
		Day beforeDay = new Day(yearYesterday, monthYesterday, dateYesterday);
		
		// 前の日の日付を返却
		return beforeDay;
		
	}
	
	/*
	*関数名：moveYesterday
	*概要：引数の日付の前の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveYesterday (Day inputDay) {
		
		// 引数の日付の前の日の日付を表示
		System.out.println("昨日の日付：" + calculateYesterday(inputDay).toString());
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-05-15 14:49:09.644
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-05-15 14:49:09.645
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-15 14:49:09.873
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap10.day4;

import static java.util.Calendar.*;

import java.util.GregorianCalendar;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class Day {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	// 年の値を1に初期化するための定数を宣言
	static final int DEFAULT_YEAR = 1;
	// 月の値を1に初期化するための定数を宣言
	static final int DEFAULT_MONTH = 1;
	// 日の値を1に初期化するための定数を宣言
	static final int DEFAULT_DATE = 1;
	// 1月を表す定数を宣言
	static final int MONTH_JANUARY = 1;
	// 2月を表す定数を宣言
	static final int MONTH_FEBRUARY = 2;
	// 12カ月分ずらすための定数を宣言
	// うるう年によって起こる曜日のずれを計算しやすいように最終月にしたいため
	static final int SHIFT_MONTHS = 12;
	// ある日付の七日後や七日前は同じ曜日になるため、七日を表す定数を宣言
	static final int SAME_DAY_OF_THE_WEEK = 7;
	// get(MONTH)の返却する値を正しい月に調整する定数を宣言
	static final int ADJUST_MONTH_NOTATION = 1;
	// うるう年が発生する条件を配列に格納し宣言
	static final int[] CONDITIONS_CONSTANT_LEAP_YEAR = {4, 100, 400};
	// 年を表す値の最小値の定数を宣言
	static final int MINIMUM_YEAR = 1;
	// 月を表す値の最大値の定数を宣言
	static final int MAXIMUM_MONTH = 12;
	// 月を表す値の最小値の定数を宣言
	static final int MINIMUM_MONTH = 1;
	// 日を表す値の最小値の定数を宣言
	static final int MINIMUM_DATE = 1;
	
	// 年を表すインスタンス変数を宣言
	private int year = DEFAULT_YEAR;
	// 月を表すインスタンス変数を宣言
	private int month = DEFAULT_MONTH;
	// 日を表すインスタンス変数を宣言
	private int date = DEFAULT_DATE;
	
	// クラスメソッド(静的メソッド)
	//-- y年は閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：年(int型)
	*戻り値：閏年であるかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public static boolean isLeap(int applicableYear) {
		
		// ツェラーの公式を用いて指定された年と条件を照らし合わせ、閏年であるかどうかを返却する(教本準拠の式)
		return applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[0] == 0 && applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[1] 
				!= 0 || applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[2] == 0;
		
	}
	
	// コンストラクタ
	// コンストラクタを多重定義
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day() {
		
		// プログラム実行時の日付を取得
		GregorianCalendar today = new GregorianCalendar();
		
		// 年を表すインスタンス変数をプログラム実行時の日付で初期化
		this.year = today.get(YEAR);
		// 月を表すインスタンス変数をプログラム実行時の日付で初期化
		this.month = today.get(MONTH) + ADJUST_MONTH_NOTATION;
		// 日を表すインスタンス変数をプログラム実行時の日付で初期化
		this.date = today.get(DATE);
		
	}
	

	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public Day(int year) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month, int date) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
		// 受け取った日の引数が日の値の最小値を下回る場合
		if (date < MINIMUM_DATE) {
			
			// 日の値を1に調整
			date = MINIMUM_DATE;
			
		// 受け取った日の引数が日の値の最大値を上回る場合
		} else if (date > findMaximumDaysOfMonth(year, month)) {
			
			// 日の値をその月の最大日数に調整
			date = findMaximumDaysOfMonth(year, month);
			
		}
		// 日を表すインスタンス変数を引数で初期化
		this.date = date;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(Day d) {
		
		// 日付のそれぞれの値を表すインスタンス変数を引数の日付で初期化
		this(d.year, d.month, d.date);
		
	}
	
	// ゲッタ
	/*
	*関数名：getYear
	*概要：年を表すフィールドの値を取得
	*引数：なし
	*戻り値：年(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getYear() { 
		
		// 年を表すフィールドの値を返却
		return year;
		
	}
	
	/*
	*関数名：getMonth
	*概要：月を表すフィールドの値を取得
	*引数：なし
	*戻り値：月(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getMonth() { 
	
		// 月を表すフィールドの値を返却
		return month;
		
	}
	
	/*
	*関数名：getDate
	*概要：日を表すフィールドの値を取得
	*引数：なし
	*戻り値：日(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getDate() {
		
		// 日を表すフィールドの値を返却
		return date;
		
	}
	
	// セッタ
	/*
	*関数名：setYear
	*概要：フィールドに指定した年の値を設定
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setYear(int year) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		
	}
	
	/*
	*関数名：setMonth
	*概要：フィールドに指定した月の値を設定
	*引数：月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setMonth(int month) { 
		
		// フィールドに指定した月の値を設定
		this.month = month;
		
	}
	
	/*
	*関数名：setDate
	*概要：フィールドに指定した日の値を設定
	*引数：日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setDate(int date) {
		
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	/*
	*関数名：set
	*概要：フィールドに指定した日付の値を設定
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void set(int year, int month, int date) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		// フィールドに指定した月の値を設定
		this.month = month;
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	// インスタンスメソッド
	//-- 閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：なし
	*戻り値：その年が閏年かどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public boolean isLeap() {
		
		// 閏年の判定をメソッドを用いて行い、正否を返却する
		return isLeap(year);
		
	}
	
	/*
	*関数名：findMaximumDaysOfMonth
	*概要：指定した年の指定した月の最大日数を返却
	*引数：年(int型)、月(int型)
	*戻り値：最大日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int findMaximumDaysOfMonth (int inputYear, int inputMonth) {
		
		// その月の最大日数を格納した配列を宣言
		final int[] MAXIMUM_DAYS_OF_MONTH = {31, isLeap(inputYear)? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		// インデックス番号を引数の年と月に対応する箇所に調整し、最大日数を返却
		return MAXIMUM_DAYS_OF_MONTH[inputMonth - 1];
		
	}
	
	/*
	*関数名：day0fWeek
	*概要：その日付の曜日を求める
	*引数：日付(Day型)
	*戻り値：曜日表す値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int day0fWeek() {
		
		// 月による曜日のずれを求める公式の定数を構成要素に持つ配列を宣言
		final int[] SHIFT_IN_DAYS_OF_WEEK = {5, 8, 13};
		
		// 年を表す変数に指定した年の値を代入
		int y = year;    
		// 月を表す変数に指定した月の値を代入
		int m = month;

		// 日付が1月か2月だった場合、前年の13月14月として扱う
		if (m == MONTH_JANUARY || m == MONTH_FEBRUARY) {

			// 年の値を1減らす
			y--;
			// 月の値に12を加算する
			m += SHIFT_MONTHS;
			
		}
		
		// 曜日を求め、日曜日から土曜日までを0から6の値で返却
		return (y + y / CONDITIONS_CONSTANT_LEAP_YEAR[0] - y / CONDITIONS_CONSTANT_LEAP_YEAR[1] + y /
				CONDITIONS_CONSTANT_LEAP_YEAR[2] + (SHIFT_IN_DAYS_OF_WEEK[2] * m + 
						SHIFT_IN_DAYS_OF_WEEK[1]) / SHIFT_IN_DAYS_OF_WEEK[0] + date) % SAME_DAY_OF_THE_WEEK;
		
	}
	
	/*
	*関数名：equalTo
	*概要：指定した日付と比較し日付が等しいかどうかを判定する
	*引数：日付(Day型)
	*戻り値：等しいかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public boolean equalTo(Day d) {
		
		// 日付を比較しその正否を返却する
		return year == d.year && month == d.month && date == d.date;
		
	}
	
	/*
	*関数名：toString
	*概要：指定した日付を文字列で表現
	*引数：なし
	*戻り値：日付の文字列表現(String型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public String toString() {
		
		// 曜日を表す文字に初期化した配列を生成
		String[] wd = { "日", "月", "火", "水", "木", "金", "土" };
		
		// 日付を文字表現で返却
		return String.format("%04d年%02d月%02d日(%s)", year, month, date, wd[day0fWeek()]);
		
	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：calculateElapsedDays
	*概要：年内での経過日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での経過日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateElapsedDays(Day inputDay) {
		
		// 経過日数を正しい値に調整するための定数を宣言
		final int ADJUST_ELAPSED_DAYS = 1;
		
		// 経過日数を表す変数を宣言(初期値は日付の日の値までの日数)
		int elapsedDays = inputDay.date - ADJUST_ELAPSED_DAYS;
			
		// その月までの月の最大日数を経過日数に加算する
		for (int i = 1; i < inputDay.month; i++) {
			
			// その月の最大日数を経過日数に加算する
			elapsedDays += findMaximumDaysOfMonth(inputDay.year, i);
			
		}
		
		// 求めた経過日数を返却する
		return elapsedDays;
		
	}
	
	/*
	*関数名：calculateDaysLeft
	*概要：年内での残り日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での残り日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateDaysLeft(Day inputDay) {
		
		// 残り日数を正しい値に調整するための定数を宣言
		final int ADJUST_LEFT_DAYS = 1;
		// その年の最大日数を格納した配列を宣言する
		final int[] MAXIMUM_DAYS_OF_YEAR = {366, 365};
		// 閏年を考慮しながら残り日数を計算する
		int daysLeft = (inputDay.isLeap() ? MAXIMUM_DAYS_OF_YEAR[0] : MAXIMUM_DAYS_OF_YEAR[1])
				- calculateElapsedDays(inputDay) - ADJUST_LEFT_DAYS;
		
		// 求めた残り日数を返却する
		return daysLeft;
		
	}
	
	/*
	*関数名：calculateQuantifiedDate
	*概要：日付を比較可能な数値へと変更する
	*引数：日付(Day型)
	*戻り値：比較可能な数値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int calculateQuantifiedDate(Day inputDay) {
		
		// 日付を比較可能な数値へと変更した際に、最初の比較箇所となる部分を表す定数を宣言
		final int FIRST_COMPARISON_POINT = 10000;
		// 日付を比較可能な数値へと変更した際に、2番目の比較箇所となる部分を表す定数を宣言
		final int SECOND_COMPARISON_POINT = 100;
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = inputDay.getYear() * FIRST_COMPARISON_POINT +
				inputDay.getMonth() * SECOND_COMPARISON_POINT + inputDay.getDate();
		
		// 数値を返却
		return inputQuantifiedDate;
		
	}
	
	/*
	*関数名：compareOtherDates
	*概要：指定された日付と比較対象となる日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static void compareOtherDates (Day inputDay) {
		
		// 比較する対象となる日付の入力を促す
		System.out.println("比較する日付を入力せよ。");
		
		// 比較する対象となる日付の年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int targetsYear = standardInput.nextInt();
		// 比較する対象となる日付の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int targetsMonth = standardInput.nextInt();
		// 比較する対象となる日付の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int targetsDate = standardInput.nextInt();
		
		// 入力された値で比較する対象となる日付を初期化
		Day targetsDay = new Day(targetsYear, targetsMonth, targetsDate);
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = calculateQuantifiedDate(inputDay);
		// 比較する対象となる日付を計算し比較可能な数値へ変更
		int targetsQuantifiedDate = calculateQuantifiedDate(targetsDay);
		
		// 二つの日付を比較し、引数の日付のほうが大きい場合
		if (inputQuantifiedDate > targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも後の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも後の日付です。");
			
		// 二つの日付を比較し、引数の日付のほうが小さい場合
		} else if (inputQuantifiedDate < targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも前の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも前の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 引数の日付と対象の日付が同じ日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "と同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：compareTwoDates
	*概要：二つの日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void compareTwoDates (Day inputFirstDay, Day inputSecondDay) {
		
		// 引数の一つ目の日付を計算し比較可能な数値へ変更
		int inputFirstQuantifiedDate = calculateQuantifiedDate(inputFirstDay);
		// 引数の二つ目の日付を計算し比較可能な数値へ変更
		int inputSecondQuantifiedDate = calculateQuantifiedDate(inputSecondDay);
		
		// 二つの日付を比較し、一つ目の日付のほうが大きい場合
		if (inputFirstQuantifiedDate > inputSecondQuantifiedDate) {
			
			// 一つ目の日付が後の日付で二つ目の日付が前の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が後の日付で、" + inputSecondDay.toString() + "が前の日付です。");
			
		// 二つの日付を比較し、二つ目の日付のほうが大きい場合
		} else if (inputFirstQuantifiedDate < inputSecondQuantifiedDate) {
			
			// 一つ目の日付が前の日付で二つ目の日付が後の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が前の日付で、" + inputSecondDay.toString() + "が後の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 二つの日付が同じ日付であることを表示
			System.out.println(inputFirstDay.toString() + "と" + inputSecondDay.toString() + "は同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：calculateTomorrow
	*概要：引数の日付の次の日の日付を返却
	*引数：日付(Day型)
	*戻り値：次の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateTomorrow (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearTomorrow = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthTomorrow = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateTomorrow = inputDay.date;
		
		// 次の日の日付の日の値を1つ進める
		++dateTomorrow;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateTomorrow > findMaximumDaysOfMonth(yearTomorrow, monthTomorrow)) {
			
			// 次の日の日付の日の値を最小値に戻す
			dateTomorrow = MINIMUM_DATE;
			// 次の日の日付の月の値を1つ進める
			++monthTomorrow;
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthTomorrow > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthTomorrow = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearTomorrow;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearTomorrow, monthTomorrow, dateTomorrow);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：moveTomorrow
	*概要：引数の日付の次の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveTomorrow (Day inputDay) {
		
		// 引数の日付の次の日の日付を表示
		System.out.println("明日の日付：" + calculateTomorrow(inputDay).toString());
		
	}
	
	/*
	*関数名：calculateSeveralDaysLater
	*概要：引数の日付の数日後の日付を返却
	*引数：日付(Day型)
	*戻り値：数日後の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateSeveralDaysLater (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearSeveralDaysLater = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthSeveralDaysLater = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateSeveralDaysLater = inputDay.date;
		
		System.out.print("何日後(有効範囲…1日以上)：");
		int shiftNumberOfDays = standardInput.nextInt();
		while (shiftNumberOfDays <= 0) {
			
			shiftNumberOfDays = inputRange();
			
		}
		
		if (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date >= shiftNumberOfDays) {
			
			dateSeveralDaysLater += shiftNumberOfDays;
			
		} else {
			
			do {
				
				shiftNumberOfDays -= (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date);
				monthSeveralDaysLater++;
				
			} (shiftNumberOfDays < 0)
			
		}
		
		// 次の日の日付の日の値を1つ進める
		dateSeveralDaysLater += shiftNumberOfDays;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateSeveralDaysLater > findMaximumDaysOfMonth(yearSeveralDaysLater, monthSeveralDaysLater)) {
			
			// 次の日の日付の月の値を1つ進める
			++monthSeveralDaysLater;
			// 次の日の日付の日の値を最小値に戻す
			dateSeveralDaysLater = MINIMUM_DATE;

			
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthSeveralDaysLater > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthSeveralDaysLater = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearSeveralDaysLater;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearSeveralDaysLater, monthSeveralDaysLater, dateSeveralDaysLater);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：calculateYesterday
	*概要：引数の日付の前の日の日付を返却
	*引数：日付(Day型)
	*戻り値：前の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/

	public static Day calculateYesterday (Day inputDay) {
		
		// 前の日の日付の年の値を引数の日付の年の値で初期化
		int yearYesterday = inputDay.year;
		// 前の日の日付の月の値を引数の日付の月の値で初期化
		int monthYesterday = inputDay.month;
		// 前の日の日付の日の値を引数の日付の日の値で初期化
		int dateYesterday = inputDay.date;
		
		// 引数の日付の各値すべてがそれぞれの最小値だった場合
		if (inputDay.year == MINIMUM_YEAR && inputDay.month == MINIMUM_MONTH || inputDay.date == MINIMUM_DATE) {
			
			// これ以上前日に戻せないことを表示
			System.out.println("これ以上前日に戻せません。");
			
		// 引数の日付の各値がどれか一つでも最小値でなかった場合
		} else {
		
			// 前の日の日付の日の値を1つ戻す
			--dateYesterday;
			
			// 前の日の日付の日の値が最小値を下回る場合
			if (dateYesterday < MINIMUM_DATE) {
				
				// 前の日の日付の月の値を1つ戻す
				--monthYesterday;
				
				// 前の日の日付の月の値が最小値を下回る場合
				if (monthYesterday < MINIMUM_MONTH) {
					
					// 前の日の日付の年の値を1つ戻す
					--yearYesterday;
					// 前の日の日付の月の値を最大値に進める
					monthYesterday = MAXIMUM_MONTH;
					
				}
				
				// 前の日の日付の日の値をその月の最大日数に進める
				dateYesterday = findMaximumDaysOfMonth(yearYesterday, monthYesterday);
				
			}
			
		}
		
		// 前の日の日付を求めた値で初期化
		Day beforeDay = new Day(yearYesterday, monthYesterday, dateYesterday);
		
		// 前の日の日付を返却
		return beforeDay;
		
	}
	
	/*
	*関数名：moveYesterday
	*概要：引数の日付の前の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveYesterday (Day inputDay) {
		
		// 引数の日付の前の日の日付を表示
		System.out.println("昨日の日付：" + calculateYesterday(inputDay).toString());
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-05-15 14:49:09.873
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-05-15 14:49:09.873
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-15 14:49:10.829
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap10.day4;

import static java.util.Calendar.*;

import java.util.GregorianCalendar;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class Day {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	// 年の値を1に初期化するための定数を宣言
	static final int DEFAULT_YEAR = 1;
	// 月の値を1に初期化するための定数を宣言
	static final int DEFAULT_MONTH = 1;
	// 日の値を1に初期化するための定数を宣言
	static final int DEFAULT_DATE = 1;
	// 1月を表す定数を宣言
	static final int MONTH_JANUARY = 1;
	// 2月を表す定数を宣言
	static final int MONTH_FEBRUARY = 2;
	// 12カ月分ずらすための定数を宣言
	// うるう年によって起こる曜日のずれを計算しやすいように最終月にしたいため
	static final int SHIFT_MONTHS = 12;
	// ある日付の七日後や七日前は同じ曜日になるため、七日を表す定数を宣言
	static final int SAME_DAY_OF_THE_WEEK = 7;
	// get(MONTH)の返却する値を正しい月に調整する定数を宣言
	static final int ADJUST_MONTH_NOTATION = 1;
	// うるう年が発生する条件を配列に格納し宣言
	static final int[] CONDITIONS_CONSTANT_LEAP_YEAR = {4, 100, 400};
	// 年を表す値の最小値の定数を宣言
	static final int MINIMUM_YEAR = 1;
	// 月を表す値の最大値の定数を宣言
	static final int MAXIMUM_MONTH = 12;
	// 月を表す値の最小値の定数を宣言
	static final int MINIMUM_MONTH = 1;
	// 日を表す値の最小値の定数を宣言
	static final int MINIMUM_DATE = 1;
	
	// 年を表すインスタンス変数を宣言
	private int year = DEFAULT_YEAR;
	// 月を表すインスタンス変数を宣言
	private int month = DEFAULT_MONTH;
	// 日を表すインスタンス変数を宣言
	private int date = DEFAULT_DATE;
	
	// クラスメソッド(静的メソッド)
	//-- y年は閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：年(int型)
	*戻り値：閏年であるかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public static boolean isLeap(int applicableYear) {
		
		// ツェラーの公式を用いて指定された年と条件を照らし合わせ、閏年であるかどうかを返却する(教本準拠の式)
		return applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[0] == 0 && applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[1] 
				!= 0 || applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[2] == 0;
		
	}
	
	// コンストラクタ
	// コンストラクタを多重定義
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day() {
		
		// プログラム実行時の日付を取得
		GregorianCalendar today = new GregorianCalendar();
		
		// 年を表すインスタンス変数をプログラム実行時の日付で初期化
		this.year = today.get(YEAR);
		// 月を表すインスタンス変数をプログラム実行時の日付で初期化
		this.month = today.get(MONTH) + ADJUST_MONTH_NOTATION;
		// 日を表すインスタンス変数をプログラム実行時の日付で初期化
		this.date = today.get(DATE);
		
	}
	

	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public Day(int year) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month, int date) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
		// 受け取った日の引数が日の値の最小値を下回る場合
		if (date < MINIMUM_DATE) {
			
			// 日の値を1に調整
			date = MINIMUM_DATE;
			
		// 受け取った日の引数が日の値の最大値を上回る場合
		} else if (date > findMaximumDaysOfMonth(year, month)) {
			
			// 日の値をその月の最大日数に調整
			date = findMaximumDaysOfMonth(year, month);
			
		}
		// 日を表すインスタンス変数を引数で初期化
		this.date = date;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(Day d) {
		
		// 日付のそれぞれの値を表すインスタンス変数を引数の日付で初期化
		this(d.year, d.month, d.date);
		
	}
	
	// ゲッタ
	/*
	*関数名：getYear
	*概要：年を表すフィールドの値を取得
	*引数：なし
	*戻り値：年(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getYear() { 
		
		// 年を表すフィールドの値を返却
		return year;
		
	}
	
	/*
	*関数名：getMonth
	*概要：月を表すフィールドの値を取得
	*引数：なし
	*戻り値：月(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getMonth() { 
	
		// 月を表すフィールドの値を返却
		return month;
		
	}
	
	/*
	*関数名：getDate
	*概要：日を表すフィールドの値を取得
	*引数：なし
	*戻り値：日(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getDate() {
		
		// 日を表すフィールドの値を返却
		return date;
		
	}
	
	// セッタ
	/*
	*関数名：setYear
	*概要：フィールドに指定した年の値を設定
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setYear(int year) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		
	}
	
	/*
	*関数名：setMonth
	*概要：フィールドに指定した月の値を設定
	*引数：月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setMonth(int month) { 
		
		// フィールドに指定した月の値を設定
		this.month = month;
		
	}
	
	/*
	*関数名：setDate
	*概要：フィールドに指定した日の値を設定
	*引数：日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setDate(int date) {
		
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	/*
	*関数名：set
	*概要：フィールドに指定した日付の値を設定
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void set(int year, int month, int date) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		// フィールドに指定した月の値を設定
		this.month = month;
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	// インスタンスメソッド
	//-- 閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：なし
	*戻り値：その年が閏年かどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public boolean isLeap() {
		
		// 閏年の判定をメソッドを用いて行い、正否を返却する
		return isLeap(year);
		
	}
	
	/*
	*関数名：findMaximumDaysOfMonth
	*概要：指定した年の指定した月の最大日数を返却
	*引数：年(int型)、月(int型)
	*戻り値：最大日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int findMaximumDaysOfMonth (int inputYear, int inputMonth) {
		
		// その月の最大日数を格納した配列を宣言
		final int[] MAXIMUM_DAYS_OF_MONTH = {31, isLeap(inputYear)? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		// インデックス番号を引数の年と月に対応する箇所に調整し、最大日数を返却
		return MAXIMUM_DAYS_OF_MONTH[inputMonth - 1];
		
	}
	
	/*
	*関数名：day0fWeek
	*概要：その日付の曜日を求める
	*引数：日付(Day型)
	*戻り値：曜日表す値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int day0fWeek() {
		
		// 月による曜日のずれを求める公式の定数を構成要素に持つ配列を宣言
		final int[] SHIFT_IN_DAYS_OF_WEEK = {5, 8, 13};
		
		// 年を表す変数に指定した年の値を代入
		int y = year;    
		// 月を表す変数に指定した月の値を代入
		int m = month;

		// 日付が1月か2月だった場合、前年の13月14月として扱う
		if (m == MONTH_JANUARY || m == MONTH_FEBRUARY) {

			// 年の値を1減らす
			y--;
			// 月の値に12を加算する
			m += SHIFT_MONTHS;
			
		}
		
		// 曜日を求め、日曜日から土曜日までを0から6の値で返却
		return (y + y / CONDITIONS_CONSTANT_LEAP_YEAR[0] - y / CONDITIONS_CONSTANT_LEAP_YEAR[1] + y /
				CONDITIONS_CONSTANT_LEAP_YEAR[2] + (SHIFT_IN_DAYS_OF_WEEK[2] * m + 
						SHIFT_IN_DAYS_OF_WEEK[1]) / SHIFT_IN_DAYS_OF_WEEK[0] + date) % SAME_DAY_OF_THE_WEEK;
		
	}
	
	/*
	*関数名：equalTo
	*概要：指定した日付と比較し日付が等しいかどうかを判定する
	*引数：日付(Day型)
	*戻り値：等しいかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public boolean equalTo(Day d) {
		
		// 日付を比較しその正否を返却する
		return year == d.year && month == d.month && date == d.date;
		
	}
	
	/*
	*関数名：toString
	*概要：指定した日付を文字列で表現
	*引数：なし
	*戻り値：日付の文字列表現(String型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public String toString() {
		
		// 曜日を表す文字に初期化した配列を生成
		String[] wd = { "日", "月", "火", "水", "木", "金", "土" };
		
		// 日付を文字表現で返却
		return String.format("%04d年%02d月%02d日(%s)", year, month, date, wd[day0fWeek()]);
		
	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：calculateElapsedDays
	*概要：年内での経過日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での経過日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateElapsedDays(Day inputDay) {
		
		// 経過日数を正しい値に調整するための定数を宣言
		final int ADJUST_ELAPSED_DAYS = 1;
		
		// 経過日数を表す変数を宣言(初期値は日付の日の値までの日数)
		int elapsedDays = inputDay.date - ADJUST_ELAPSED_DAYS;
			
		// その月までの月の最大日数を経過日数に加算する
		for (int i = 1; i < inputDay.month; i++) {
			
			// その月の最大日数を経過日数に加算する
			elapsedDays += findMaximumDaysOfMonth(inputDay.year, i);
			
		}
		
		// 求めた経過日数を返却する
		return elapsedDays;
		
	}
	
	/*
	*関数名：calculateDaysLeft
	*概要：年内での残り日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での残り日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateDaysLeft(Day inputDay) {
		
		// 残り日数を正しい値に調整するための定数を宣言
		final int ADJUST_LEFT_DAYS = 1;
		// その年の最大日数を格納した配列を宣言する
		final int[] MAXIMUM_DAYS_OF_YEAR = {366, 365};
		// 閏年を考慮しながら残り日数を計算する
		int daysLeft = (inputDay.isLeap() ? MAXIMUM_DAYS_OF_YEAR[0] : MAXIMUM_DAYS_OF_YEAR[1])
				- calculateElapsedDays(inputDay) - ADJUST_LEFT_DAYS;
		
		// 求めた残り日数を返却する
		return daysLeft;
		
	}
	
	/*
	*関数名：calculateQuantifiedDate
	*概要：日付を比較可能な数値へと変更する
	*引数：日付(Day型)
	*戻り値：比較可能な数値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int calculateQuantifiedDate(Day inputDay) {
		
		// 日付を比較可能な数値へと変更した際に、最初の比較箇所となる部分を表す定数を宣言
		final int FIRST_COMPARISON_POINT = 10000;
		// 日付を比較可能な数値へと変更した際に、2番目の比較箇所となる部分を表す定数を宣言
		final int SECOND_COMPARISON_POINT = 100;
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = inputDay.getYear() * FIRST_COMPARISON_POINT +
				inputDay.getMonth() * SECOND_COMPARISON_POINT + inputDay.getDate();
		
		// 数値を返却
		return inputQuantifiedDate;
		
	}
	
	/*
	*関数名：compareOtherDates
	*概要：指定された日付と比較対象となる日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static void compareOtherDates (Day inputDay) {
		
		// 比較する対象となる日付の入力を促す
		System.out.println("比較する日付を入力せよ。");
		
		// 比較する対象となる日付の年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int targetsYear = standardInput.nextInt();
		// 比較する対象となる日付の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int targetsMonth = standardInput.nextInt();
		// 比較する対象となる日付の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int targetsDate = standardInput.nextInt();
		
		// 入力された値で比較する対象となる日付を初期化
		Day targetsDay = new Day(targetsYear, targetsMonth, targetsDate);
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = calculateQuantifiedDate(inputDay);
		// 比較する対象となる日付を計算し比較可能な数値へ変更
		int targetsQuantifiedDate = calculateQuantifiedDate(targetsDay);
		
		// 二つの日付を比較し、引数の日付のほうが大きい場合
		if (inputQuantifiedDate > targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも後の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも後の日付です。");
			
		// 二つの日付を比較し、引数の日付のほうが小さい場合
		} else if (inputQuantifiedDate < targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも前の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも前の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 引数の日付と対象の日付が同じ日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "と同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：compareTwoDates
	*概要：二つの日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void compareTwoDates (Day inputFirstDay, Day inputSecondDay) {
		
		// 引数の一つ目の日付を計算し比較可能な数値へ変更
		int inputFirstQuantifiedDate = calculateQuantifiedDate(inputFirstDay);
		// 引数の二つ目の日付を計算し比較可能な数値へ変更
		int inputSecondQuantifiedDate = calculateQuantifiedDate(inputSecondDay);
		
		// 二つの日付を比較し、一つ目の日付のほうが大きい場合
		if (inputFirstQuantifiedDate > inputSecondQuantifiedDate) {
			
			// 一つ目の日付が後の日付で二つ目の日付が前の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が後の日付で、" + inputSecondDay.toString() + "が前の日付です。");
			
		// 二つの日付を比較し、二つ目の日付のほうが大きい場合
		} else if (inputFirstQuantifiedDate < inputSecondQuantifiedDate) {
			
			// 一つ目の日付が前の日付で二つ目の日付が後の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が前の日付で、" + inputSecondDay.toString() + "が後の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 二つの日付が同じ日付であることを表示
			System.out.println(inputFirstDay.toString() + "と" + inputSecondDay.toString() + "は同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：calculateTomorrow
	*概要：引数の日付の次の日の日付を返却
	*引数：日付(Day型)
	*戻り値：次の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateTomorrow (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearTomorrow = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthTomorrow = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateTomorrow = inputDay.date;
		
		// 次の日の日付の日の値を1つ進める
		++dateTomorrow;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateTomorrow > findMaximumDaysOfMonth(yearTomorrow, monthTomorrow)) {
			
			// 次の日の日付の日の値を最小値に戻す
			dateTomorrow = MINIMUM_DATE;
			// 次の日の日付の月の値を1つ進める
			++monthTomorrow;
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthTomorrow > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthTomorrow = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearTomorrow;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearTomorrow, monthTomorrow, dateTomorrow);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：moveTomorrow
	*概要：引数の日付の次の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveTomorrow (Day inputDay) {
		
		// 引数の日付の次の日の日付を表示
		System.out.println("明日の日付：" + calculateTomorrow(inputDay).toString());
		
	}
	
	/*
	*関数名：calculateSeveralDaysLater
	*概要：引数の日付の数日後の日付を返却
	*引数：日付(Day型)
	*戻り値：数日後の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateSeveralDaysLater (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearSeveralDaysLater = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthSeveralDaysLater = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateSeveralDaysLater = inputDay.date;
		
		System.out.print("何日後(有効範囲…1日以上)：");
		int shiftNumberOfDays = standardInput.nextInt();
		while (shiftNumberOfDays <= 0) {
			
			shiftNumberOfDays = inputRange();
			
		}
		
		if (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date >= shiftNumberOfDays) {
			
			dateSeveralDaysLater += shiftNumberOfDays;
			
		} else {
			
			do {
				
				shiftNumberOfDays -= (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date);
				monthSeveralDaysLater++;
				
			} (shiftNumberOfDays < 0)
			
		}
		
		// 次の日の日付の日の値を1つ進める
		dateSeveralDaysLater += shiftNumberOfDays;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateSeveralDaysLater > findMaximumDaysOfMonth(yearSeveralDaysLater, monthSeveralDaysLater)) {
			
			// 次の日の日付の月の値を1つ進める
			++monthSeveralDaysLater;
			// 次の日の日付の日の値を最小値に戻す
			dateSeveralDaysLater = MINIMUM_DATE;

			
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthSeveralDaysLater > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthSeveralDaysLater = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearSeveralDaysLater;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearSeveralDaysLater, monthSeveralDaysLater, dateSeveralDaysLater);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：calculateYesterday
	*概要：引数の日付の前の日の日付を返却
	*引数：日付(Day型)
	*戻り値：前の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/

	public static Day calculateYesterday (Day inputDay) {
		
		// 前の日の日付の年の値を引数の日付の年の値で初期化
		int yearYesterday = inputDay.year;
		// 前の日の日付の月の値を引数の日付の月の値で初期化
		int monthYesterday = inputDay.month;
		// 前の日の日付の日の値を引数の日付の日の値で初期化
		int dateYesterday = inputDay.date;
		
		// 引数の日付の各値すべてがそれぞれの最小値だった場合
		if (inputDay.year == MINIMUM_YEAR && inputDay.month == MINIMUM_MONTH || inputDay.date == MINIMUM_DATE) {
			
			// これ以上前日に戻せないことを表示
			System.out.println("これ以上前日に戻せません。");
			
		// 引数の日付の各値がどれか一つでも最小値でなかった場合
		} else {
		
			// 前の日の日付の日の値を1つ戻す
			--dateYesterday;
			
			// 前の日の日付の日の値が最小値を下回る場合
			if (dateYesterday < MINIMUM_DATE) {
				
				// 前の日の日付の月の値を1つ戻す
				--monthYesterday;
				
				// 前の日の日付の月の値が最小値を下回る場合
				if (monthYesterday < MINIMUM_MONTH) {
					
					// 前の日の日付の年の値を1つ戻す
					--yearYesterday;
					// 前の日の日付の月の値を最大値に進める
					monthYesterday = MAXIMUM_MONTH;
					
				}
				
				// 前の日の日付の日の値をその月の最大日数に進める
				dateYesterday = findMaximumDaysOfMonth(yearYesterday, monthYesterday);
				
			}
			
		}
		
		// 前の日の日付を求めた値で初期化
		Day beforeDay = new Day(yearYesterday, monthYesterday, dateYesterday);
		
		// 前の日の日付を返却
		return beforeDay;
		
	}
	
	/*
	*関数名：moveYesterday
	*概要：引数の日付の前の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveYesterday (Day inputDay) {
		
		// 引数の日付の前の日の日付を表示
		System.out.println("昨日の日付：" + calculateYesterday(inputDay).toString());
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-05-15 14:49:10.830
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-05-15 14:49:10.830
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-15 14:49:13.874
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap10.day4;

import static java.util.Calendar.*;

import java.util.GregorianCalendar;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class Day {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	// 年の値を1に初期化するための定数を宣言
	static final int DEFAULT_YEAR = 1;
	// 月の値を1に初期化するための定数を宣言
	static final int DEFAULT_MONTH = 1;
	// 日の値を1に初期化するための定数を宣言
	static final int DEFAULT_DATE = 1;
	// 1月を表す定数を宣言
	static final int MONTH_JANUARY = 1;
	// 2月を表す定数を宣言
	static final int MONTH_FEBRUARY = 2;
	// 12カ月分ずらすための定数を宣言
	// うるう年によって起こる曜日のずれを計算しやすいように最終月にしたいため
	static final int SHIFT_MONTHS = 12;
	// ある日付の七日後や七日前は同じ曜日になるため、七日を表す定数を宣言
	static final int SAME_DAY_OF_THE_WEEK = 7;
	// get(MONTH)の返却する値を正しい月に調整する定数を宣言
	static final int ADJUST_MONTH_NOTATION = 1;
	// うるう年が発生する条件を配列に格納し宣言
	static final int[] CONDITIONS_CONSTANT_LEAP_YEAR = {4, 100, 400};
	// 年を表す値の最小値の定数を宣言
	static final int MINIMUM_YEAR = 1;
	// 月を表す値の最大値の定数を宣言
	static final int MAXIMUM_MONTH = 12;
	// 月を表す値の最小値の定数を宣言
	static final int MINIMUM_MONTH = 1;
	// 日を表す値の最小値の定数を宣言
	static final int MINIMUM_DATE = 1;
	
	// 年を表すインスタンス変数を宣言
	private int year = DEFAULT_YEAR;
	// 月を表すインスタンス変数を宣言
	private int month = DEFAULT_MONTH;
	// 日を表すインスタンス変数を宣言
	private int date = DEFAULT_DATE;
	
	// クラスメソッド(静的メソッド)
	//-- y年は閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：年(int型)
	*戻り値：閏年であるかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public static boolean isLeap(int applicableYear) {
		
		// ツェラーの公式を用いて指定された年と条件を照らし合わせ、閏年であるかどうかを返却する(教本準拠の式)
		return applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[0] == 0 && applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[1] 
				!= 0 || applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[2] == 0;
		
	}
	
	// コンストラクタ
	// コンストラクタを多重定義
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day() {
		
		// プログラム実行時の日付を取得
		GregorianCalendar today = new GregorianCalendar();
		
		// 年を表すインスタンス変数をプログラム実行時の日付で初期化
		this.year = today.get(YEAR);
		// 月を表すインスタンス変数をプログラム実行時の日付で初期化
		this.month = today.get(MONTH) + ADJUST_MONTH_NOTATION;
		// 日を表すインスタンス変数をプログラム実行時の日付で初期化
		this.date = today.get(DATE);
		
	}
	

	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public Day(int year) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month, int date) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
		// 受け取った日の引数が日の値の最小値を下回る場合
		if (date < MINIMUM_DATE) {
			
			// 日の値を1に調整
			date = MINIMUM_DATE;
			
		// 受け取った日の引数が日の値の最大値を上回る場合
		} else if (date > findMaximumDaysOfMonth(year, month)) {
			
			// 日の値をその月の最大日数に調整
			date = findMaximumDaysOfMonth(year, month);
			
		}
		// 日を表すインスタンス変数を引数で初期化
		this.date = date;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(Day d) {
		
		// 日付のそれぞれの値を表すインスタンス変数を引数の日付で初期化
		this(d.year, d.month, d.date);
		
	}
	
	// ゲッタ
	/*
	*関数名：getYear
	*概要：年を表すフィールドの値を取得
	*引数：なし
	*戻り値：年(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getYear() { 
		
		// 年を表すフィールドの値を返却
		return year;
		
	}
	
	/*
	*関数名：getMonth
	*概要：月を表すフィールドの値を取得
	*引数：なし
	*戻り値：月(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getMonth() { 
	
		// 月を表すフィールドの値を返却
		return month;
		
	}
	
	/*
	*関数名：getDate
	*概要：日を表すフィールドの値を取得
	*引数：なし
	*戻り値：日(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getDate() {
		
		// 日を表すフィールドの値を返却
		return date;
		
	}
	
	// セッタ
	/*
	*関数名：setYear
	*概要：フィールドに指定した年の値を設定
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setYear(int year) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		
	}
	
	/*
	*関数名：setMonth
	*概要：フィールドに指定した月の値を設定
	*引数：月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setMonth(int month) { 
		
		// フィールドに指定した月の値を設定
		this.month = month;
		
	}
	
	/*
	*関数名：setDate
	*概要：フィールドに指定した日の値を設定
	*引数：日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setDate(int date) {
		
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	/*
	*関数名：set
	*概要：フィールドに指定した日付の値を設定
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void set(int year, int month, int date) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		// フィールドに指定した月の値を設定
		this.month = month;
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	// インスタンスメソッド
	//-- 閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：なし
	*戻り値：その年が閏年かどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public boolean isLeap() {
		
		// 閏年の判定をメソッドを用いて行い、正否を返却する
		return isLeap(year);
		
	}
	
	/*
	*関数名：findMaximumDaysOfMonth
	*概要：指定した年の指定した月の最大日数を返却
	*引数：年(int型)、月(int型)
	*戻り値：最大日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int findMaximumDaysOfMonth (int inputYear, int inputMonth) {
		
		// その月の最大日数を格納した配列を宣言
		final int[] MAXIMUM_DAYS_OF_MONTH = {31, isLeap(inputYear)? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		// インデックス番号を引数の年と月に対応する箇所に調整し、最大日数を返却
		return MAXIMUM_DAYS_OF_MONTH[inputMonth - 1];
		
	}
	
	/*
	*関数名：day0fWeek
	*概要：その日付の曜日を求める
	*引数：日付(Day型)
	*戻り値：曜日表す値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int day0fWeek() {
		
		// 月による曜日のずれを求める公式の定数を構成要素に持つ配列を宣言
		final int[] SHIFT_IN_DAYS_OF_WEEK = {5, 8, 13};
		
		// 年を表す変数に指定した年の値を代入
		int y = year;    
		// 月を表す変数に指定した月の値を代入
		int m = month;

		// 日付が1月か2月だった場合、前年の13月14月として扱う
		if (m == MONTH_JANUARY || m == MONTH_FEBRUARY) {

			// 年の値を1減らす
			y--;
			// 月の値に12を加算する
			m += SHIFT_MONTHS;
			
		}
		
		// 曜日を求め、日曜日から土曜日までを0から6の値で返却
		return (y + y / CONDITIONS_CONSTANT_LEAP_YEAR[0] - y / CONDITIONS_CONSTANT_LEAP_YEAR[1] + y /
				CONDITIONS_CONSTANT_LEAP_YEAR[2] + (SHIFT_IN_DAYS_OF_WEEK[2] * m + 
						SHIFT_IN_DAYS_OF_WEEK[1]) / SHIFT_IN_DAYS_OF_WEEK[0] + date) % SAME_DAY_OF_THE_WEEK;
		
	}
	
	/*
	*関数名：equalTo
	*概要：指定した日付と比較し日付が等しいかどうかを判定する
	*引数：日付(Day型)
	*戻り値：等しいかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public boolean equalTo(Day d) {
		
		// 日付を比較しその正否を返却する
		return year == d.year && month == d.month && date == d.date;
		
	}
	
	/*
	*関数名：toString
	*概要：指定した日付を文字列で表現
	*引数：なし
	*戻り値：日付の文字列表現(String型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public String toString() {
		
		// 曜日を表す文字に初期化した配列を生成
		String[] wd = { "日", "月", "火", "水", "木", "金", "土" };
		
		// 日付を文字表現で返却
		return String.format("%04d年%02d月%02d日(%s)", year, month, date, wd[day0fWeek()]);
		
	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：calculateElapsedDays
	*概要：年内での経過日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での経過日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateElapsedDays(Day inputDay) {
		
		// 経過日数を正しい値に調整するための定数を宣言
		final int ADJUST_ELAPSED_DAYS = 1;
		
		// 経過日数を表す変数を宣言(初期値は日付の日の値までの日数)
		int elapsedDays = inputDay.date - ADJUST_ELAPSED_DAYS;
			
		// その月までの月の最大日数を経過日数に加算する
		for (int i = 1; i < inputDay.month; i++) {
			
			// その月の最大日数を経過日数に加算する
			elapsedDays += findMaximumDaysOfMonth(inputDay.year, i);
			
		}
		
		// 求めた経過日数を返却する
		return elapsedDays;
		
	}
	
	/*
	*関数名：calculateDaysLeft
	*概要：年内での残り日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での残り日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateDaysLeft(Day inputDay) {
		
		// 残り日数を正しい値に調整するための定数を宣言
		final int ADJUST_LEFT_DAYS = 1;
		// その年の最大日数を格納した配列を宣言する
		final int[] MAXIMUM_DAYS_OF_YEAR = {366, 365};
		// 閏年を考慮しながら残り日数を計算する
		int daysLeft = (inputDay.isLeap() ? MAXIMUM_DAYS_OF_YEAR[0] : MAXIMUM_DAYS_OF_YEAR[1])
				- calculateElapsedDays(inputDay) - ADJUST_LEFT_DAYS;
		
		// 求めた残り日数を返却する
		return daysLeft;
		
	}
	
	/*
	*関数名：calculateQuantifiedDate
	*概要：日付を比較可能な数値へと変更する
	*引数：日付(Day型)
	*戻り値：比較可能な数値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int calculateQuantifiedDate(Day inputDay) {
		
		// 日付を比較可能な数値へと変更した際に、最初の比較箇所となる部分を表す定数を宣言
		final int FIRST_COMPARISON_POINT = 10000;
		// 日付を比較可能な数値へと変更した際に、2番目の比較箇所となる部分を表す定数を宣言
		final int SECOND_COMPARISON_POINT = 100;
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = inputDay.getYear() * FIRST_COMPARISON_POINT +
				inputDay.getMonth() * SECOND_COMPARISON_POINT + inputDay.getDate();
		
		// 数値を返却
		return inputQuantifiedDate;
		
	}
	
	/*
	*関数名：compareOtherDates
	*概要：指定された日付と比較対象となる日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static void compareOtherDates (Day inputDay) {
		
		// 比較する対象となる日付の入力を促す
		System.out.println("比較する日付を入力せよ。");
		
		// 比較する対象となる日付の年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int targetsYear = standardInput.nextInt();
		// 比較する対象となる日付の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int targetsMonth = standardInput.nextInt();
		// 比較する対象となる日付の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int targetsDate = standardInput.nextInt();
		
		// 入力された値で比較する対象となる日付を初期化
		Day targetsDay = new Day(targetsYear, targetsMonth, targetsDate);
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = calculateQuantifiedDate(inputDay);
		// 比較する対象となる日付を計算し比較可能な数値へ変更
		int targetsQuantifiedDate = calculateQuantifiedDate(targetsDay);
		
		// 二つの日付を比較し、引数の日付のほうが大きい場合
		if (inputQuantifiedDate > targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも後の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも後の日付です。");
			
		// 二つの日付を比較し、引数の日付のほうが小さい場合
		} else if (inputQuantifiedDate < targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも前の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも前の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 引数の日付と対象の日付が同じ日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "と同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：compareTwoDates
	*概要：二つの日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void compareTwoDates (Day inputFirstDay, Day inputSecondDay) {
		
		// 引数の一つ目の日付を計算し比較可能な数値へ変更
		int inputFirstQuantifiedDate = calculateQuantifiedDate(inputFirstDay);
		// 引数の二つ目の日付を計算し比較可能な数値へ変更
		int inputSecondQuantifiedDate = calculateQuantifiedDate(inputSecondDay);
		
		// 二つの日付を比較し、一つ目の日付のほうが大きい場合
		if (inputFirstQuantifiedDate > inputSecondQuantifiedDate) {
			
			// 一つ目の日付が後の日付で二つ目の日付が前の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が後の日付で、" + inputSecondDay.toString() + "が前の日付です。");
			
		// 二つの日付を比較し、二つ目の日付のほうが大きい場合
		} else if (inputFirstQuantifiedDate < inputSecondQuantifiedDate) {
			
			// 一つ目の日付が前の日付で二つ目の日付が後の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が前の日付で、" + inputSecondDay.toString() + "が後の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 二つの日付が同じ日付であることを表示
			System.out.println(inputFirstDay.toString() + "と" + inputSecondDay.toString() + "は同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：calculateTomorrow
	*概要：引数の日付の次の日の日付を返却
	*引数：日付(Day型)
	*戻り値：次の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateTomorrow (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearTomorrow = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthTomorrow = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateTomorrow = inputDay.date;
		
		// 次の日の日付の日の値を1つ進める
		++dateTomorrow;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateTomorrow > findMaximumDaysOfMonth(yearTomorrow, monthTomorrow)) {
			
			// 次の日の日付の日の値を最小値に戻す
			dateTomorrow = MINIMUM_DATE;
			// 次の日の日付の月の値を1つ進める
			++monthTomorrow;
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthTomorrow > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthTomorrow = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearTomorrow;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearTomorrow, monthTomorrow, dateTomorrow);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：moveTomorrow
	*概要：引数の日付の次の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveTomorrow (Day inputDay) {
		
		// 引数の日付の次の日の日付を表示
		System.out.println("明日の日付：" + calculateTomorrow(inputDay).toString());
		
	}
	
	/*
	*関数名：calculateSeveralDaysLater
	*概要：引数の日付の数日後の日付を返却
	*引数：日付(Day型)
	*戻り値：数日後の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateSeveralDaysLater (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearSeveralDaysLater = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthSeveralDaysLater = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateSeveralDaysLater = inputDay.date;
		
		System.out.print("何日後(有効範囲…1日以上)：");
		int shiftNumberOfDays = standardInput.nextInt();
		while (shiftNumberOfDays <= 0) {
			
			shiftNumberOfDays = inputRange();
			
		}
		
		if (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date >= shiftNumberOfDays) {
			
			dateSeveralDaysLater += shiftNumberOfDays;
			
		} else {
			
			do {
				
				shiftNumberOfDays -= (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date);
				monthSeveralDaysLater++;
				
			} (shiftNumberOfDays < 0)
			
		}
		
		// 次の日の日付の日の値を1つ進める
		dateSeveralDaysLater += shiftNumberOfDays;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateSeveralDaysLater > findMaximumDaysOfMonth(yearSeveralDaysLater, monthSeveralDaysLater)) {
			
			// 次の日の日付の月の値を1つ進める
			++monthSeveralDaysLater;
			// 次の日の日付の日の値を最小値に戻す
			dateSeveralDaysLater = MINIMUM_DATE;

			
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthSeveralDaysLater > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthSeveralDaysLater = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearSeveralDaysLater;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearSeveralDaysLater, monthSeveralDaysLater, dateSeveralDaysLater);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：calculateYesterday
	*概要：引数の日付の前の日の日付を返却
	*引数：日付(Day型)
	*戻り値：前の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/

	public static Day calculateYesterday (Day inputDay) {
		
		// 前の日の日付の年の値を引数の日付の年の値で初期化
		int yearYesterday = inputDay.year;
		// 前の日の日付の月の値を引数の日付の月の値で初期化
		int monthYesterday = inputDay.month;
		// 前の日の日付の日の値を引数の日付の日の値で初期化
		int dateYesterday = inputDay.date;
		
		// 引数の日付の各値すべてがそれぞれの最小値だった場合
		if (inputDay.year == MINIMUM_YEAR && inputDay.month == MINIMUM_MONTH || inputDay.date == MINIMUM_DATE) {
			
			// これ以上前日に戻せないことを表示
			System.out.println("これ以上前日に戻せません。");
			
		// 引数の日付の各値がどれか一つでも最小値でなかった場合
		} else {
		
			// 前の日の日付の日の値を1つ戻す
			--dateYesterday;
			
			// 前の日の日付の日の値が最小値を下回る場合
			if (dateYesterday < MINIMUM_DATE) {
				
				// 前の日の日付の月の値を1つ戻す
				--monthYesterday;
				
				// 前の日の日付の月の値が最小値を下回る場合
				if (monthYesterday < MINIMUM_MONTH) {
					
					// 前の日の日付の年の値を1つ戻す
					--yearYesterday;
					// 前の日の日付の月の値を最大値に進める
					monthYesterday = MAXIMUM_MONTH;
					
				}
				
				// 前の日の日付の日の値をその月の最大日数に進める
				dateYesterday = findMaximumDaysOfMonth(yearYesterday, monthYesterday);
				
			}
			
		}
		
		// 前の日の日付を求めた値で初期化
		Day beforeDay = new Day(yearYesterday, monthYesterday, dateYesterday);
		
		// 前の日の日付を返却
		return beforeDay;
		
	}
	
	/*
	*関数名：moveYesterday
	*概要：引数の日付の前の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveYesterday (Day inputDay) {
		
		// 引数の日付の前の日の日付を表示
		System.out.println("昨日の日付：" + calculateYesterday(inputDay).toString());
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-05-15 14:49:13.874
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-05-15 14:49:13.874
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-15 14:49:13.920
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap10.day4;

import static java.util.Calendar.*;

import java.util.GregorianCalendar;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class Day {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	// 年の値を1に初期化するための定数を宣言
	static final int DEFAULT_YEAR = 1;
	// 月の値を1に初期化するための定数を宣言
	static final int DEFAULT_MONTH = 1;
	// 日の値を1に初期化するための定数を宣言
	static final int DEFAULT_DATE = 1;
	// 1月を表す定数を宣言
	static final int MONTH_JANUARY = 1;
	// 2月を表す定数を宣言
	static final int MONTH_FEBRUARY = 2;
	// 12カ月分ずらすための定数を宣言
	// うるう年によって起こる曜日のずれを計算しやすいように最終月にしたいため
	static final int SHIFT_MONTHS = 12;
	// ある日付の七日後や七日前は同じ曜日になるため、七日を表す定数を宣言
	static final int SAME_DAY_OF_THE_WEEK = 7;
	// get(MONTH)の返却する値を正しい月に調整する定数を宣言
	static final int ADJUST_MONTH_NOTATION = 1;
	// うるう年が発生する条件を配列に格納し宣言
	static final int[] CONDITIONS_CONSTANT_LEAP_YEAR = {4, 100, 400};
	// 年を表す値の最小値の定数を宣言
	static final int MINIMUM_YEAR = 1;
	// 月を表す値の最大値の定数を宣言
	static final int MAXIMUM_MONTH = 12;
	// 月を表す値の最小値の定数を宣言
	static final int MINIMUM_MONTH = 1;
	// 日を表す値の最小値の定数を宣言
	static final int MINIMUM_DATE = 1;
	
	// 年を表すインスタンス変数を宣言
	private int year = DEFAULT_YEAR;
	// 月を表すインスタンス変数を宣言
	private int month = DEFAULT_MONTH;
	// 日を表すインスタンス変数を宣言
	private int date = DEFAULT_DATE;
	
	// クラスメソッド(静的メソッド)
	//-- y年は閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：年(int型)
	*戻り値：閏年であるかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public static boolean isLeap(int applicableYear) {
		
		// ツェラーの公式を用いて指定された年と条件を照らし合わせ、閏年であるかどうかを返却する(教本準拠の式)
		return applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[0] == 0 && applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[1] 
				!= 0 || applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[2] == 0;
		
	}
	
	// コンストラクタ
	// コンストラクタを多重定義
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day() {
		
		// プログラム実行時の日付を取得
		GregorianCalendar today = new GregorianCalendar();
		
		// 年を表すインスタンス変数をプログラム実行時の日付で初期化
		this.year = today.get(YEAR);
		// 月を表すインスタンス変数をプログラム実行時の日付で初期化
		this.month = today.get(MONTH) + ADJUST_MONTH_NOTATION;
		// 日を表すインスタンス変数をプログラム実行時の日付で初期化
		this.date = today.get(DATE);
		
	}
	

	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public Day(int year) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month, int date) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
		// 受け取った日の引数が日の値の最小値を下回る場合
		if (date < MINIMUM_DATE) {
			
			// 日の値を1に調整
			date = MINIMUM_DATE;
			
		// 受け取った日の引数が日の値の最大値を上回る場合
		} else if (date > findMaximumDaysOfMonth(year, month)) {
			
			// 日の値をその月の最大日数に調整
			date = findMaximumDaysOfMonth(year, month);
			
		}
		// 日を表すインスタンス変数を引数で初期化
		this.date = date;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(Day d) {
		
		// 日付のそれぞれの値を表すインスタンス変数を引数の日付で初期化
		this(d.year, d.month, d.date);
		
	}
	
	// ゲッタ
	/*
	*関数名：getYear
	*概要：年を表すフィールドの値を取得
	*引数：なし
	*戻り値：年(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getYear() { 
		
		// 年を表すフィールドの値を返却
		return year;
		
	}
	
	/*
	*関数名：getMonth
	*概要：月を表すフィールドの値を取得
	*引数：なし
	*戻り値：月(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getMonth() { 
	
		// 月を表すフィールドの値を返却
		return month;
		
	}
	
	/*
	*関数名：getDate
	*概要：日を表すフィールドの値を取得
	*引数：なし
	*戻り値：日(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getDate() {
		
		// 日を表すフィールドの値を返却
		return date;
		
	}
	
	// セッタ
	/*
	*関数名：setYear
	*概要：フィールドに指定した年の値を設定
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setYear(int year) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		
	}
	
	/*
	*関数名：setMonth
	*概要：フィールドに指定した月の値を設定
	*引数：月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setMonth(int month) { 
		
		// フィールドに指定した月の値を設定
		this.month = month;
		
	}
	
	/*
	*関数名：setDate
	*概要：フィールドに指定した日の値を設定
	*引数：日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setDate(int date) {
		
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	/*
	*関数名：set
	*概要：フィールドに指定した日付の値を設定
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void set(int year, int month, int date) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		// フィールドに指定した月の値を設定
		this.month = month;
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	// インスタンスメソッド
	//-- 閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：なし
	*戻り値：その年が閏年かどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public boolean isLeap() {
		
		// 閏年の判定をメソッドを用いて行い、正否を返却する
		return isLeap(year);
		
	}
	
	/*
	*関数名：findMaximumDaysOfMonth
	*概要：指定した年の指定した月の最大日数を返却
	*引数：年(int型)、月(int型)
	*戻り値：最大日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int findMaximumDaysOfMonth (int inputYear, int inputMonth) {
		
		// その月の最大日数を格納した配列を宣言
		final int[] MAXIMUM_DAYS_OF_MONTH = {31, isLeap(inputYear)? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		// インデックス番号を引数の年と月に対応する箇所に調整し、最大日数を返却
		return MAXIMUM_DAYS_OF_MONTH[inputMonth - 1];
		
	}
	
	/*
	*関数名：day0fWeek
	*概要：その日付の曜日を求める
	*引数：日付(Day型)
	*戻り値：曜日表す値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int day0fWeek() {
		
		// 月による曜日のずれを求める公式の定数を構成要素に持つ配列を宣言
		final int[] SHIFT_IN_DAYS_OF_WEEK = {5, 8, 13};
		
		// 年を表す変数に指定した年の値を代入
		int y = year;    
		// 月を表す変数に指定した月の値を代入
		int m = month;

		// 日付が1月か2月だった場合、前年の13月14月として扱う
		if (m == MONTH_JANUARY || m == MONTH_FEBRUARY) {

			// 年の値を1減らす
			y--;
			// 月の値に12を加算する
			m += SHIFT_MONTHS;
			
		}
		
		// 曜日を求め、日曜日から土曜日までを0から6の値で返却
		return (y + y / CONDITIONS_CONSTANT_LEAP_YEAR[0] - y / CONDITIONS_CONSTANT_LEAP_YEAR[1] + y /
				CONDITIONS_CONSTANT_LEAP_YEAR[2] + (SHIFT_IN_DAYS_OF_WEEK[2] * m + 
						SHIFT_IN_DAYS_OF_WEEK[1]) / SHIFT_IN_DAYS_OF_WEEK[0] + date) % SAME_DAY_OF_THE_WEEK;
		
	}
	
	/*
	*関数名：equalTo
	*概要：指定した日付と比較し日付が等しいかどうかを判定する
	*引数：日付(Day型)
	*戻り値：等しいかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public boolean equalTo(Day d) {
		
		// 日付を比較しその正否を返却する
		return year == d.year && month == d.month && date == d.date;
		
	}
	
	/*
	*関数名：toString
	*概要：指定した日付を文字列で表現
	*引数：なし
	*戻り値：日付の文字列表現(String型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public String toString() {
		
		// 曜日を表す文字に初期化した配列を生成
		String[] wd = { "日", "月", "火", "水", "木", "金", "土" };
		
		// 日付を文字表現で返却
		return String.format("%04d年%02d月%02d日(%s)", year, month, date, wd[day0fWeek()]);
		
	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：calculateElapsedDays
	*概要：年内での経過日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での経過日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateElapsedDays(Day inputDay) {
		
		// 経過日数を正しい値に調整するための定数を宣言
		final int ADJUST_ELAPSED_DAYS = 1;
		
		// 経過日数を表す変数を宣言(初期値は日付の日の値までの日数)
		int elapsedDays = inputDay.date - ADJUST_ELAPSED_DAYS;
			
		// その月までの月の最大日数を経過日数に加算する
		for (int i = 1; i < inputDay.month; i++) {
			
			// その月の最大日数を経過日数に加算する
			elapsedDays += findMaximumDaysOfMonth(inputDay.year, i);
			
		}
		
		// 求めた経過日数を返却する
		return elapsedDays;
		
	}
	
	/*
	*関数名：calculateDaysLeft
	*概要：年内での残り日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での残り日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateDaysLeft(Day inputDay) {
		
		// 残り日数を正しい値に調整するための定数を宣言
		final int ADJUST_LEFT_DAYS = 1;
		// その年の最大日数を格納した配列を宣言する
		final int[] MAXIMUM_DAYS_OF_YEAR = {366, 365};
		// 閏年を考慮しながら残り日数を計算する
		int daysLeft = (inputDay.isLeap() ? MAXIMUM_DAYS_OF_YEAR[0] : MAXIMUM_DAYS_OF_YEAR[1])
				- calculateElapsedDays(inputDay) - ADJUST_LEFT_DAYS;
		
		// 求めた残り日数を返却する
		return daysLeft;
		
	}
	
	/*
	*関数名：calculateQuantifiedDate
	*概要：日付を比較可能な数値へと変更する
	*引数：日付(Day型)
	*戻り値：比較可能な数値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int calculateQuantifiedDate(Day inputDay) {
		
		// 日付を比較可能な数値へと変更した際に、最初の比較箇所となる部分を表す定数を宣言
		final int FIRST_COMPARISON_POINT = 10000;
		// 日付を比較可能な数値へと変更した際に、2番目の比較箇所となる部分を表す定数を宣言
		final int SECOND_COMPARISON_POINT = 100;
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = inputDay.getYear() * FIRST_COMPARISON_POINT +
				inputDay.getMonth() * SECOND_COMPARISON_POINT + inputDay.getDate();
		
		// 数値を返却
		return inputQuantifiedDate;
		
	}
	
	/*
	*関数名：compareOtherDates
	*概要：指定された日付と比較対象となる日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static void compareOtherDates (Day inputDay) {
		
		// 比較する対象となる日付の入力を促す
		System.out.println("比較する日付を入力せよ。");
		
		// 比較する対象となる日付の年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int targetsYear = standardInput.nextInt();
		// 比較する対象となる日付の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int targetsMonth = standardInput.nextInt();
		// 比較する対象となる日付の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int targetsDate = standardInput.nextInt();
		
		// 入力された値で比較する対象となる日付を初期化
		Day targetsDay = new Day(targetsYear, targetsMonth, targetsDate);
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = calculateQuantifiedDate(inputDay);
		// 比較する対象となる日付を計算し比較可能な数値へ変更
		int targetsQuantifiedDate = calculateQuantifiedDate(targetsDay);
		
		// 二つの日付を比較し、引数の日付のほうが大きい場合
		if (inputQuantifiedDate > targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも後の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも後の日付です。");
			
		// 二つの日付を比較し、引数の日付のほうが小さい場合
		} else if (inputQuantifiedDate < targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも前の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも前の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 引数の日付と対象の日付が同じ日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "と同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：compareTwoDates
	*概要：二つの日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void compareTwoDates (Day inputFirstDay, Day inputSecondDay) {
		
		// 引数の一つ目の日付を計算し比較可能な数値へ変更
		int inputFirstQuantifiedDate = calculateQuantifiedDate(inputFirstDay);
		// 引数の二つ目の日付を計算し比較可能な数値へ変更
		int inputSecondQuantifiedDate = calculateQuantifiedDate(inputSecondDay);
		
		// 二つの日付を比較し、一つ目の日付のほうが大きい場合
		if (inputFirstQuantifiedDate > inputSecondQuantifiedDate) {
			
			// 一つ目の日付が後の日付で二つ目の日付が前の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が後の日付で、" + inputSecondDay.toString() + "が前の日付です。");
			
		// 二つの日付を比較し、二つ目の日付のほうが大きい場合
		} else if (inputFirstQuantifiedDate < inputSecondQuantifiedDate) {
			
			// 一つ目の日付が前の日付で二つ目の日付が後の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が前の日付で、" + inputSecondDay.toString() + "が後の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 二つの日付が同じ日付であることを表示
			System.out.println(inputFirstDay.toString() + "と" + inputSecondDay.toString() + "は同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：calculateTomorrow
	*概要：引数の日付の次の日の日付を返却
	*引数：日付(Day型)
	*戻り値：次の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateTomorrow (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearTomorrow = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthTomorrow = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateTomorrow = inputDay.date;
		
		// 次の日の日付の日の値を1つ進める
		++dateTomorrow;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateTomorrow > findMaximumDaysOfMonth(yearTomorrow, monthTomorrow)) {
			
			// 次の日の日付の日の値を最小値に戻す
			dateTomorrow = MINIMUM_DATE;
			// 次の日の日付の月の値を1つ進める
			++monthTomorrow;
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthTomorrow > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthTomorrow = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearTomorrow;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearTomorrow, monthTomorrow, dateTomorrow);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：moveTomorrow
	*概要：引数の日付の次の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveTomorrow (Day inputDay) {
		
		// 引数の日付の次の日の日付を表示
		System.out.println("明日の日付：" + calculateTomorrow(inputDay).toString());
		
	}
	
	/*
	*関数名：calculateSeveralDaysLater
	*概要：引数の日付の数日後の日付を返却
	*引数：日付(Day型)
	*戻り値：数日後の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateSeveralDaysLater (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearSeveralDaysLater = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthSeveralDaysLater = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateSeveralDaysLater = inputDay.date;
		
		System.out.print("何日後(有効範囲…1日以上)：");
		int shiftNumberOfDays = standardInput.nextInt();
		while (shiftNumberOfDays <= 0) {
			
			shiftNumberOfDays = inputRange();
			
		}
		
		if (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date >= shiftNumberOfDays) {
			
			dateSeveralDaysLater += shiftNumberOfDays;
			
		} else {
			
			do {
				
				shiftNumberOfDays -= (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date);
				monthSeveralDaysLater++;
				
			} (shiftNumberOfDays < 0)
			
		}
		
		// 次の日の日付の日の値を1つ進める
		dateSeveralDaysLater += shiftNumberOfDays;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateSeveralDaysLater > findMaximumDaysOfMonth(yearSeveralDaysLater, monthSeveralDaysLater)) {
			
			// 次の日の日付の月の値を1つ進める
			++monthSeveralDaysLater;
			// 次の日の日付の日の値を最小値に戻す
			dateSeveralDaysLater = MINIMUM_DATE;

			
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthSeveralDaysLater > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthSeveralDaysLater = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearSeveralDaysLater;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearSeveralDaysLater, monthSeveralDaysLater, dateSeveralDaysLater);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：calculateYesterday
	*概要：引数の日付の前の日の日付を返却
	*引数：日付(Day型)
	*戻り値：前の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/

	public static Day calculateYesterday (Day inputDay) {
		
		// 前の日の日付の年の値を引数の日付の年の値で初期化
		int yearYesterday = inputDay.year;
		// 前の日の日付の月の値を引数の日付の月の値で初期化
		int monthYesterday = inputDay.month;
		// 前の日の日付の日の値を引数の日付の日の値で初期化
		int dateYesterday = inputDay.date;
		
		// 引数の日付の各値すべてがそれぞれの最小値だった場合
		if (inputDay.year == MINIMUM_YEAR && inputDay.month == MINIMUM_MONTH || inputDay.date == MINIMUM_DATE) {
			
			// これ以上前日に戻せないことを表示
			System.out.println("これ以上前日に戻せません。");
			
		// 引数の日付の各値がどれか一つでも最小値でなかった場合
		} else {
		
			// 前の日の日付の日の値を1つ戻す
			--dateYesterday;
			
			// 前の日の日付の日の値が最小値を下回る場合
			if (dateYesterday < MINIMUM_DATE) {
				
				// 前の日の日付の月の値を1つ戻す
				--monthYesterday;
				
				// 前の日の日付の月の値が最小値を下回る場合
				if (monthYesterday < MINIMUM_MONTH) {
					
					// 前の日の日付の年の値を1つ戻す
					--yearYesterday;
					// 前の日の日付の月の値を最大値に進める
					monthYesterday = MAXIMUM_MONTH;
					
				}
				
				// 前の日の日付の日の値をその月の最大日数に進める
				dateYesterday = findMaximumDaysOfMonth(yearYesterday, monthYesterday);
				
			}
			
		}
		
		// 前の日の日付を求めた値で初期化
		Day beforeDay = new Day(yearYesterday, monthYesterday, dateYesterday);
		
		// 前の日の日付を返却
		return beforeDay;
		
	}
	
	/*
	*関数名：moveYesterday
	*概要：引数の日付の前の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveYesterday (Day inputDay) {
		
		// 引数の日付の前の日の日付を表示
		System.out.println("昨日の日付：" + calculateYesterday(inputDay).toString());
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-05-15 14:49:13.920
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-05-15 14:49:13.920
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-15 14:49:22.487
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap10.day4;

import static java.util.Calendar.*;

import java.util.GregorianCalendar;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class Day {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	// 年の値を1に初期化するための定数を宣言
	static final int DEFAULT_YEAR = 1;
	// 月の値を1に初期化するための定数を宣言
	static final int DEFAULT_MONTH = 1;
	// 日の値を1に初期化するための定数を宣言
	static final int DEFAULT_DATE = 1;
	// 1月を表す定数を宣言
	static final int MONTH_JANUARY = 1;
	// 2月を表す定数を宣言
	static final int MONTH_FEBRUARY = 2;
	// 12カ月分ずらすための定数を宣言
	// うるう年によって起こる曜日のずれを計算しやすいように最終月にしたいため
	static final int SHIFT_MONTHS = 12;
	// ある日付の七日後や七日前は同じ曜日になるため、七日を表す定数を宣言
	static final int SAME_DAY_OF_THE_WEEK = 7;
	// get(MONTH)の返却する値を正しい月に調整する定数を宣言
	static final int ADJUST_MONTH_NOTATION = 1;
	// うるう年が発生する条件を配列に格納し宣言
	static final int[] CONDITIONS_CONSTANT_LEAP_YEAR = {4, 100, 400};
	// 年を表す値の最小値の定数を宣言
	static final int MINIMUM_YEAR = 1;
	// 月を表す値の最大値の定数を宣言
	static final int MAXIMUM_MONTH = 12;
	// 月を表す値の最小値の定数を宣言
	static final int MINIMUM_MONTH = 1;
	// 日を表す値の最小値の定数を宣言
	static final int MINIMUM_DATE = 1;
	
	// 年を表すインスタンス変数を宣言
	private int year = DEFAULT_YEAR;
	// 月を表すインスタンス変数を宣言
	private int month = DEFAULT_MONTH;
	// 日を表すインスタンス変数を宣言
	private int date = DEFAULT_DATE;
	
	// クラスメソッド(静的メソッド)
	//-- y年は閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：年(int型)
	*戻り値：閏年であるかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public static boolean isLeap(int applicableYear) {
		
		// ツェラーの公式を用いて指定された年と条件を照らし合わせ、閏年であるかどうかを返却する(教本準拠の式)
		return applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[0] == 0 && applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[1] 
				!= 0 || applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[2] == 0;
		
	}
	
	// コンストラクタ
	// コンストラクタを多重定義
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day() {
		
		// プログラム実行時の日付を取得
		GregorianCalendar today = new GregorianCalendar();
		
		// 年を表すインスタンス変数をプログラム実行時の日付で初期化
		this.year = today.get(YEAR);
		// 月を表すインスタンス変数をプログラム実行時の日付で初期化
		this.month = today.get(MONTH) + ADJUST_MONTH_NOTATION;
		// 日を表すインスタンス変数をプログラム実行時の日付で初期化
		this.date = today.get(DATE);
		
	}
	

	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public Day(int year) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month, int date) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
		// 受け取った日の引数が日の値の最小値を下回る場合
		if (date < MINIMUM_DATE) {
			
			// 日の値を1に調整
			date = MINIMUM_DATE;
			
		// 受け取った日の引数が日の値の最大値を上回る場合
		} else if (date > findMaximumDaysOfMonth(year, month)) {
			
			// 日の値をその月の最大日数に調整
			date = findMaximumDaysOfMonth(year, month);
			
		}
		// 日を表すインスタンス変数を引数で初期化
		this.date = date;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(Day d) {
		
		// 日付のそれぞれの値を表すインスタンス変数を引数の日付で初期化
		this(d.year, d.month, d.date);
		
	}
	
	// ゲッタ
	/*
	*関数名：getYear
	*概要：年を表すフィールドの値を取得
	*引数：なし
	*戻り値：年(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getYear() { 
		
		// 年を表すフィールドの値を返却
		return year;
		
	}
	
	/*
	*関数名：getMonth
	*概要：月を表すフィールドの値を取得
	*引数：なし
	*戻り値：月(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getMonth() { 
	
		// 月を表すフィールドの値を返却
		return month;
		
	}
	
	/*
	*関数名：getDate
	*概要：日を表すフィールドの値を取得
	*引数：なし
	*戻り値：日(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getDate() {
		
		// 日を表すフィールドの値を返却
		return date;
		
	}
	
	// セッタ
	/*
	*関数名：setYear
	*概要：フィールドに指定した年の値を設定
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setYear(int year) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		
	}
	
	/*
	*関数名：setMonth
	*概要：フィールドに指定した月の値を設定
	*引数：月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setMonth(int month) { 
		
		// フィールドに指定した月の値を設定
		this.month = month;
		
	}
	
	/*
	*関数名：setDate
	*概要：フィールドに指定した日の値を設定
	*引数：日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setDate(int date) {
		
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	/*
	*関数名：set
	*概要：フィールドに指定した日付の値を設定
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void set(int year, int month, int date) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		// フィールドに指定した月の値を設定
		this.month = month;
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	// インスタンスメソッド
	//-- 閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：なし
	*戻り値：その年が閏年かどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public boolean isLeap() {
		
		// 閏年の判定をメソッドを用いて行い、正否を返却する
		return isLeap(year);
		
	}
	
	/*
	*関数名：findMaximumDaysOfMonth
	*概要：指定した年の指定した月の最大日数を返却
	*引数：年(int型)、月(int型)
	*戻り値：最大日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int findMaximumDaysOfMonth (int inputYear, int inputMonth) {
		
		// その月の最大日数を格納した配列を宣言
		final int[] MAXIMUM_DAYS_OF_MONTH = {31, isLeap(inputYear)? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		// インデックス番号を引数の年と月に対応する箇所に調整し、最大日数を返却
		return MAXIMUM_DAYS_OF_MONTH[inputMonth - 1];
		
	}
	
	/*
	*関数名：day0fWeek
	*概要：その日付の曜日を求める
	*引数：日付(Day型)
	*戻り値：曜日表す値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int day0fWeek() {
		
		// 月による曜日のずれを求める公式の定数を構成要素に持つ配列を宣言
		final int[] SHIFT_IN_DAYS_OF_WEEK = {5, 8, 13};
		
		// 年を表す変数に指定した年の値を代入
		int y = year;    
		// 月を表す変数に指定した月の値を代入
		int m = month;

		// 日付が1月か2月だった場合、前年の13月14月として扱う
		if (m == MONTH_JANUARY || m == MONTH_FEBRUARY) {

			// 年の値を1減らす
			y--;
			// 月の値に12を加算する
			m += SHIFT_MONTHS;
			
		}
		
		// 曜日を求め、日曜日から土曜日までを0から6の値で返却
		return (y + y / CONDITIONS_CONSTANT_LEAP_YEAR[0] - y / CONDITIONS_CONSTANT_LEAP_YEAR[1] + y /
				CONDITIONS_CONSTANT_LEAP_YEAR[2] + (SHIFT_IN_DAYS_OF_WEEK[2] * m + 
						SHIFT_IN_DAYS_OF_WEEK[1]) / SHIFT_IN_DAYS_OF_WEEK[0] + date) % SAME_DAY_OF_THE_WEEK;
		
	}
	
	/*
	*関数名：equalTo
	*概要：指定した日付と比較し日付が等しいかどうかを判定する
	*引数：日付(Day型)
	*戻り値：等しいかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public boolean equalTo(Day d) {
		
		// 日付を比較しその正否を返却する
		return year == d.year && month == d.month && date == d.date;
		
	}
	
	/*
	*関数名：toString
	*概要：指定した日付を文字列で表現
	*引数：なし
	*戻り値：日付の文字列表現(String型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public String toString() {
		
		// 曜日を表す文字に初期化した配列を生成
		String[] wd = { "日", "月", "火", "水", "木", "金", "土" };
		
		// 日付を文字表現で返却
		return String.format("%04d年%02d月%02d日(%s)", year, month, date, wd[day0fWeek()]);
		
	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：calculateElapsedDays
	*概要：年内での経過日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での経過日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateElapsedDays(Day inputDay) {
		
		// 経過日数を正しい値に調整するための定数を宣言
		final int ADJUST_ELAPSED_DAYS = 1;
		
		// 経過日数を表す変数を宣言(初期値は日付の日の値までの日数)
		int elapsedDays = inputDay.date - ADJUST_ELAPSED_DAYS;
			
		// その月までの月の最大日数を経過日数に加算する
		for (int i = 1; i < inputDay.month; i++) {
			
			// その月の最大日数を経過日数に加算する
			elapsedDays += findMaximumDaysOfMonth(inputDay.year, i);
			
		}
		
		// 求めた経過日数を返却する
		return elapsedDays;
		
	}
	
	/*
	*関数名：calculateDaysLeft
	*概要：年内での残り日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での残り日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateDaysLeft(Day inputDay) {
		
		// 残り日数を正しい値に調整するための定数を宣言
		final int ADJUST_LEFT_DAYS = 1;
		// その年の最大日数を格納した配列を宣言する
		final int[] MAXIMUM_DAYS_OF_YEAR = {366, 365};
		// 閏年を考慮しながら残り日数を計算する
		int daysLeft = (inputDay.isLeap() ? MAXIMUM_DAYS_OF_YEAR[0] : MAXIMUM_DAYS_OF_YEAR[1])
				- calculateElapsedDays(inputDay) - ADJUST_LEFT_DAYS;
		
		// 求めた残り日数を返却する
		return daysLeft;
		
	}
	
	/*
	*関数名：calculateQuantifiedDate
	*概要：日付を比較可能な数値へと変更する
	*引数：日付(Day型)
	*戻り値：比較可能な数値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int calculateQuantifiedDate(Day inputDay) {
		
		// 日付を比較可能な数値へと変更した際に、最初の比較箇所となる部分を表す定数を宣言
		final int FIRST_COMPARISON_POINT = 10000;
		// 日付を比較可能な数値へと変更した際に、2番目の比較箇所となる部分を表す定数を宣言
		final int SECOND_COMPARISON_POINT = 100;
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = inputDay.getYear() * FIRST_COMPARISON_POINT +
				inputDay.getMonth() * SECOND_COMPARISON_POINT + inputDay.getDate();
		
		// 数値を返却
		return inputQuantifiedDate;
		
	}
	
	/*
	*関数名：compareOtherDates
	*概要：指定された日付と比較対象となる日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static void compareOtherDates (Day inputDay) {
		
		// 比較する対象となる日付の入力を促す
		System.out.println("比較する日付を入力せよ。");
		
		// 比較する対象となる日付の年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int targetsYear = standardInput.nextInt();
		// 比較する対象となる日付の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int targetsMonth = standardInput.nextInt();
		// 比較する対象となる日付の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int targetsDate = standardInput.nextInt();
		
		// 入力された値で比較する対象となる日付を初期化
		Day targetsDay = new Day(targetsYear, targetsMonth, targetsDate);
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = calculateQuantifiedDate(inputDay);
		// 比較する対象となる日付を計算し比較可能な数値へ変更
		int targetsQuantifiedDate = calculateQuantifiedDate(targetsDay);
		
		// 二つの日付を比較し、引数の日付のほうが大きい場合
		if (inputQuantifiedDate > targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも後の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも後の日付です。");
			
		// 二つの日付を比較し、引数の日付のほうが小さい場合
		} else if (inputQuantifiedDate < targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも前の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも前の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 引数の日付と対象の日付が同じ日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "と同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：compareTwoDates
	*概要：二つの日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void compareTwoDates (Day inputFirstDay, Day inputSecondDay) {
		
		// 引数の一つ目の日付を計算し比較可能な数値へ変更
		int inputFirstQuantifiedDate = calculateQuantifiedDate(inputFirstDay);
		// 引数の二つ目の日付を計算し比較可能な数値へ変更
		int inputSecondQuantifiedDate = calculateQuantifiedDate(inputSecondDay);
		
		// 二つの日付を比較し、一つ目の日付のほうが大きい場合
		if (inputFirstQuantifiedDate > inputSecondQuantifiedDate) {
			
			// 一つ目の日付が後の日付で二つ目の日付が前の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が後の日付で、" + inputSecondDay.toString() + "が前の日付です。");
			
		// 二つの日付を比較し、二つ目の日付のほうが大きい場合
		} else if (inputFirstQuantifiedDate < inputSecondQuantifiedDate) {
			
			// 一つ目の日付が前の日付で二つ目の日付が後の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が前の日付で、" + inputSecondDay.toString() + "が後の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 二つの日付が同じ日付であることを表示
			System.out.println(inputFirstDay.toString() + "と" + inputSecondDay.toString() + "は同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：calculateTomorrow
	*概要：引数の日付の次の日の日付を返却
	*引数：日付(Day型)
	*戻り値：次の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateTomorrow (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearTomorrow = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthTomorrow = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateTomorrow = inputDay.date;
		
		// 次の日の日付の日の値を1つ進める
		++dateTomorrow;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateTomorrow > findMaximumDaysOfMonth(yearTomorrow, monthTomorrow)) {
			
			// 次の日の日付の日の値を最小値に戻す
			dateTomorrow = MINIMUM_DATE;
			// 次の日の日付の月の値を1つ進める
			++monthTomorrow;
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthTomorrow > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthTomorrow = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearTomorrow;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearTomorrow, monthTomorrow, dateTomorrow);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：moveTomorrow
	*概要：引数の日付の次の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveTomorrow (Day inputDay) {
		
		// 引数の日付の次の日の日付を表示
		System.out.println("明日の日付：" + calculateTomorrow(inputDay).toString());
		
	}
	
	/*
	*関数名：calculateSeveralDaysLater
	*概要：引数の日付の数日後の日付を返却
	*引数：日付(Day型)
	*戻り値：数日後の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateSeveralDaysLater (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearSeveralDaysLater = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthSeveralDaysLater = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateSeveralDaysLater = inputDay.date;
		
		System.out.print("何日後(有効範囲…1日以上)：");
		int shiftNumberOfDays = standardInput.nextInt();
		while (shiftNumberOfDays <= 0) {
			
			shiftNumberOfDays = inputRange();
			
		}
		
		if (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date >= shiftNumberOfDays) {
			
			dateSeveralDaysLater += shiftNumberOfDays;
			
		} else {
			
			do {
				
				shiftNumberOfDays -= (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date);
				monthSeveralDaysLater++;
				
			} (shiftNumberOfDays < 0)
			
		}
		
		// 次の日の日付の日の値を1つ進める
		dateSeveralDaysLater += shiftNumberOfDays;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateSeveralDaysLater > findMaximumDaysOfMonth(yearSeveralDaysLater, monthSeveralDaysLater)) {
			
			// 次の日の日付の月の値を1つ進める
			++monthSeveralDaysLater;
			// 次の日の日付の日の値を最小値に戻す
			dateSeveralDaysLater = MINIMUM_DATE;

			
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthSeveralDaysLater > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthSeveralDaysLater = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearSeveralDaysLater;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearSeveralDaysLater, monthSeveralDaysLater, dateSeveralDaysLater);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：calculateYesterday
	*概要：引数の日付の前の日の日付を返却
	*引数：日付(Day型)
	*戻り値：前の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/

	public static Day calculateYesterday (Day inputDay) {
		
		// 前の日の日付の年の値を引数の日付の年の値で初期化
		int yearYesterday = inputDay.year;
		// 前の日の日付の月の値を引数の日付の月の値で初期化
		int monthYesterday = inputDay.month;
		// 前の日の日付の日の値を引数の日付の日の値で初期化
		int dateYesterday = inputDay.date;
		
		// 引数の日付の各値すべてがそれぞれの最小値だった場合
		if (inputDay.year == MINIMUM_YEAR && inputDay.month == MINIMUM_MONTH || inputDay.date == MINIMUM_DATE) {
			
			// これ以上前日に戻せないことを表示
			System.out.println("これ以上前日に戻せません。");
			
		// 引数の日付の各値がどれか一つでも最小値でなかった場合
		} else {
		
			// 前の日の日付の日の値を1つ戻す
			--dateYesterday;
			
			// 前の日の日付の日の値が最小値を下回る場合
			if (dateYesterday < MINIMUM_DATE) {
				
				// 前の日の日付の月の値を1つ戻す
				--monthYesterday;
				
				// 前の日の日付の月の値が最小値を下回る場合
				if (monthYesterday < MINIMUM_MONTH) {
					
					// 前の日の日付の年の値を1つ戻す
					--yearYesterday;
					// 前の日の日付の月の値を最大値に進める
					monthYesterday = MAXIMUM_MONTH;
					
				}
				
				// 前の日の日付の日の値をその月の最大日数に進める
				dateYesterday = findMaximumDaysOfMonth(yearYesterday, monthYesterday);
				
			}
			
		}
		
		// 前の日の日付を求めた値で初期化
		Day beforeDay = new Day(yearYesterday, monthYesterday, dateYesterday);
		
		// 前の日の日付を返却
		return beforeDay;
		
	}
	
	/*
	*関数名：moveYesterday
	*概要：引数の日付の前の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveYesterday (Day inputDay) {
		
		// 引数の日付の前の日の日付を表示
		System.out.println("昨日の日付：" + calculateYesterday(inputDay).toString());
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-05-15 14:49:22.487
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-05-15 14:49:22.487
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-15 14:49:23.438
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap10.day4;

import static java.util.Calendar.*;

import java.util.GregorianCalendar;
//Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class Day {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	// 年の値を1に初期化するための定数を宣言
	static final int DEFAULT_YEAR = 1;
	// 月の値を1に初期化するための定数を宣言
	static final int DEFAULT_MONTH = 1;
	// 日の値を1に初期化するための定数を宣言
	static final int DEFAULT_DATE = 1;
	// 1月を表す定数を宣言
	static final int MONTH_JANUARY = 1;
	// 2月を表す定数を宣言
	static final int MONTH_FEBRUARY = 2;
	// 12カ月分ずらすための定数を宣言
	// うるう年によって起こる曜日のずれを計算しやすいように最終月にしたいため
	static final int SHIFT_MONTHS = 12;
	// ある日付の七日後や七日前は同じ曜日になるため、七日を表す定数を宣言
	static final int SAME_DAY_OF_THE_WEEK = 7;
	// get(MONTH)の返却する値を正しい月に調整する定数を宣言
	static final int ADJUST_MONTH_NOTATION = 1;
	// うるう年が発生する条件を配列に格納し宣言
	static final int[] CONDITIONS_CONSTANT_LEAP_YEAR = {4, 100, 400};
	// 年を表す値の最小値の定数を宣言
	static final int MINIMUM_YEAR = 1;
	// 月を表す値の最大値の定数を宣言
	static final int MAXIMUM_MONTH = 12;
	// 月を表す値の最小値の定数を宣言
	static final int MINIMUM_MONTH = 1;
	// 日を表す値の最小値の定数を宣言
	static final int MINIMUM_DATE = 1;
	
	// 年を表すインスタンス変数を宣言
	private int year = DEFAULT_YEAR;
	// 月を表すインスタンス変数を宣言
	private int month = DEFAULT_MONTH;
	// 日を表すインスタンス変数を宣言
	private int date = DEFAULT_DATE;
	
	// クラスメソッド(静的メソッド)
	//-- y年は閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：年(int型)
	*戻り値：閏年であるかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public static boolean isLeap(int applicableYear) {
		
		// ツェラーの公式を用いて指定された年と条件を照らし合わせ、閏年であるかどうかを返却する(教本準拠の式)
		return applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[0] == 0 && applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[1] 
				!= 0 || applicableYear % CONDITIONS_CONSTANT_LEAP_YEAR[2] == 0;
		
	}
	
	// コンストラクタ
	// コンストラクタを多重定義
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day() {
		
		// プログラム実行時の日付を取得
		GregorianCalendar today = new GregorianCalendar();
		
		// 年を表すインスタンス変数をプログラム実行時の日付で初期化
		this.year = today.get(YEAR);
		// 月を表すインスタンス変数をプログラム実行時の日付で初期化
		this.month = today.get(MONTH) + ADJUST_MONTH_NOTATION;
		// 日を表すインスタンス変数をプログラム実行時の日付で初期化
		this.date = today.get(DATE);
		
	}
	

	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public Day(int year) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(int year, int month, int date) {
		
		// 受け取った年の引数が最小値を下回る場合
		if (year < MINIMUM_YEAR) {
			
			// 年の値を1最小値に調整
			year = MINIMUM_YEAR;
			
		}
		// 年を表すインスタンス変数を引数で初期化
		this.year = year;
		
		// 受け取った月の引数が月の値の最小値を下回る場合
		if (month < MINIMUM_MONTH) {
			
			// 月の値を最小値に調整
			month = MINIMUM_MONTH;
			
			// 受け取った月の引数が月の値の最大値を上回る場合
		} else if (month > MAXIMUM_MONTH) {
			
			// 月の値を最大値に調整
			month = MAXIMUM_MONTH;
			
		}
		// 月を表すインスタンス変数を引数で初期化
		this.month = month;
		
		// 受け取った日の引数が日の値の最小値を下回る場合
		if (date < MINIMUM_DATE) {
			
			// 日の値を1に調整
			date = MINIMUM_DATE;
			
		// 受け取った日の引数が日の値の最大値を上回る場合
		} else if (date > findMaximumDaysOfMonth(year, month)) {
			
			// 日の値をその月の最大日数に調整
			date = findMaximumDaysOfMonth(year, month);
			
		}
		// 日を表すインスタンス変数を引数で初期化
		this.date = date;
		
	}
	
	/*
	*コンストラクタ名：Day
	*概要：インスタンスの初期化
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public Day(Day d) {
		
		// 日付のそれぞれの値を表すインスタンス変数を引数の日付で初期化
		this(d.year, d.month, d.date);
		
	}
	
	// ゲッタ
	/*
	*関数名：getYear
	*概要：年を表すフィールドの値を取得
	*引数：なし
	*戻り値：年(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getYear() { 
		
		// 年を表すフィールドの値を返却
		return year;
		
	}
	
	/*
	*関数名：getMonth
	*概要：月を表すフィールドの値を取得
	*引数：なし
	*戻り値：月(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getMonth() { 
	
		// 月を表すフィールドの値を返却
		return month;
		
	}
	
	/*
	*関数名：getDate
	*概要：日を表すフィールドの値を取得
	*引数：なし
	*戻り値：日(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int getDate() {
		
		// 日を表すフィールドの値を返却
		return date;
		
	}
	
	// セッタ
	/*
	*関数名：setYear
	*概要：フィールドに指定した年の値を設定
	*引数：年(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setYear(int year) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		
	}
	
	/*
	*関数名：setMonth
	*概要：フィールドに指定した月の値を設定
	*引数：月(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setMonth(int month) { 
		
		// フィールドに指定した月の値を設定
		this.month = month;
		
	}
	
	/*
	*関数名：setDate
	*概要：フィールドに指定した日の値を設定
	*引数：日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void setDate(int date) {
		
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	/*
	*関数名：set
	*概要：フィールドに指定した日付の値を設定
	*引数：年(int型)、月(int型)、日(int型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public void set(int year, int month, int date) {
		
		// フィールドに指定した年の値を設定
		this.year = year;
		// フィールドに指定した月の値を設定
		this.month = month;
		// フィールドに指定した日の値を設定
		this.date = date;
		
	}
	
	// インスタンスメソッド
	//-- 閏年か？ --//
	
	/*
	*関数名：isLeap
	*概要：その年が閏年かどうか判定する
	*引数：なし
	*戻り値：その年が閏年かどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/14
	*/
	
	public boolean isLeap() {
		
		// 閏年の判定をメソッドを用いて行い、正否を返却する
		return isLeap(year);
		
	}
	
	/*
	*関数名：findMaximumDaysOfMonth
	*概要：指定した年の指定した月の最大日数を返却
	*引数：年(int型)、月(int型)
	*戻り値：最大日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int findMaximumDaysOfMonth (int inputYear, int inputMonth) {
		
		// その月の最大日数を格納した配列を宣言
		final int[] MAXIMUM_DAYS_OF_MONTH = {31, isLeap(inputYear)? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		// インデックス番号を引数の年と月に対応する箇所に調整し、最大日数を返却
		return MAXIMUM_DAYS_OF_MONTH[inputMonth - 1];
		
	}
	
	/*
	*関数名：day0fWeek
	*概要：その日付の曜日を求める
	*引数：日付(Day型)
	*戻り値：曜日表す値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public int day0fWeek() {
		
		// 月による曜日のずれを求める公式の定数を構成要素に持つ配列を宣言
		final int[] SHIFT_IN_DAYS_OF_WEEK = {5, 8, 13};
		
		// 年を表す変数に指定した年の値を代入
		int y = year;    
		// 月を表す変数に指定した月の値を代入
		int m = month;

		// 日付が1月か2月だった場合、前年の13月14月として扱う
		if (m == MONTH_JANUARY || m == MONTH_FEBRUARY) {

			// 年の値を1減らす
			y--;
			// 月の値に12を加算する
			m += SHIFT_MONTHS;
			
		}
		
		// 曜日を求め、日曜日から土曜日までを0から6の値で返却
		return (y + y / CONDITIONS_CONSTANT_LEAP_YEAR[0] - y / CONDITIONS_CONSTANT_LEAP_YEAR[1] + y /
				CONDITIONS_CONSTANT_LEAP_YEAR[2] + (SHIFT_IN_DAYS_OF_WEEK[2] * m + 
						SHIFT_IN_DAYS_OF_WEEK[1]) / SHIFT_IN_DAYS_OF_WEEK[0] + date) % SAME_DAY_OF_THE_WEEK;
		
	}
	
	/*
	*関数名：equalTo
	*概要：指定した日付と比較し日付が等しいかどうかを判定する
	*引数：日付(Day型)
	*戻り値：等しいかどうか(boolean型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public boolean equalTo(Day d) {
		
		// 日付を比較しその正否を返却する
		return year == d.year && month == d.month && date == d.date;
		
	}
	
	/*
	*関数名：toString
	*概要：指定した日付を文字列で表現
	*引数：なし
	*戻り値：日付の文字列表現(String型)
	*作成者：N.Kimoto
	*作成日：2024/05/02
	*/
	
	public String toString() {
		
		// 曜日を表す文字に初期化した配列を生成
		String[] wd = { "日", "月", "火", "水", "木", "金", "土" };
		
		// 日付を文字表現で返却
		return String.format("%04d年%02d月%02d日(%s)", year, month, date, wd[day0fWeek()]);
		
	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：calculateElapsedDays
	*概要：年内での経過日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での経過日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateElapsedDays(Day inputDay) {
		
		// 経過日数を正しい値に調整するための定数を宣言
		final int ADJUST_ELAPSED_DAYS = 1;
		
		// 経過日数を表す変数を宣言(初期値は日付の日の値までの日数)
		int elapsedDays = inputDay.date - ADJUST_ELAPSED_DAYS;
			
		// その月までの月の最大日数を経過日数に加算する
		for (int i = 1; i < inputDay.month; i++) {
			
			// その月の最大日数を経過日数に加算する
			elapsedDays += findMaximumDaysOfMonth(inputDay.year, i);
			
		}
		
		// 求めた経過日数を返却する
		return elapsedDays;
		
	}
	
	/*
	*関数名：calculateDaysLeft
	*概要：年内での残り日数を求め、その値を返却する
	*引数：日付(Day型)
	*戻り値：年内での残り日数(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static int calculateDaysLeft(Day inputDay) {
		
		// 残り日数を正しい値に調整するための定数を宣言
		final int ADJUST_LEFT_DAYS = 1;
		// その年の最大日数を格納した配列を宣言する
		final int[] MAXIMUM_DAYS_OF_YEAR = {366, 365};
		// 閏年を考慮しながら残り日数を計算する
		int daysLeft = (inputDay.isLeap() ? MAXIMUM_DAYS_OF_YEAR[0] : MAXIMUM_DAYS_OF_YEAR[1])
				- calculateElapsedDays(inputDay) - ADJUST_LEFT_DAYS;
		
		// 求めた残り日数を返却する
		return daysLeft;
		
	}
	
	/*
	*関数名：calculateQuantifiedDate
	*概要：日付を比較可能な数値へと変更する
	*引数：日付(Day型)
	*戻り値：比較可能な数値(int型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static int calculateQuantifiedDate(Day inputDay) {
		
		// 日付を比較可能な数値へと変更した際に、最初の比較箇所となる部分を表す定数を宣言
		final int FIRST_COMPARISON_POINT = 10000;
		// 日付を比較可能な数値へと変更した際に、2番目の比較箇所となる部分を表す定数を宣言
		final int SECOND_COMPARISON_POINT = 100;
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = inputDay.getYear() * FIRST_COMPARISON_POINT +
				inputDay.getMonth() * SECOND_COMPARISON_POINT + inputDay.getDate();
		
		// 数値を返却
		return inputQuantifiedDate;
		
	}
	
	/*
	*関数名：compareOtherDates
	*概要：指定された日付と比較対象となる日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/13
	*/
	
	public static void compareOtherDates (Day inputDay) {
		
		// 比較する対象となる日付の入力を促す
		System.out.println("比較する日付を入力せよ。");
		
		// 比較する対象となる日付の年の値の入力を促す
		System.out.print("年：");
		// 入力された値を読み込む
		int targetsYear = standardInput.nextInt();
		// 比較する対象となる日付の月の値の入力を促す
		System.out.print("月：");
		// 入力された値を読み込む
		int targetsMonth = standardInput.nextInt();
		// 比較する対象となる日付の日の値の入力を促す
		System.out.print("日：");
		// 入力された値を読み込む
		int targetsDate = standardInput.nextInt();
		
		// 入力された値で比較する対象となる日付を初期化
		Day targetsDay = new Day(targetsYear, targetsMonth, targetsDate);
		
		// 引数の日付を計算し比較可能な数値へ変更
		int inputQuantifiedDate = calculateQuantifiedDate(inputDay);
		// 比較する対象となる日付を計算し比較可能な数値へ変更
		int targetsQuantifiedDate = calculateQuantifiedDate(targetsDay);
		
		// 二つの日付を比較し、引数の日付のほうが大きい場合
		if (inputQuantifiedDate > targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも後の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも後の日付です。");
			
		// 二つの日付を比較し、引数の日付のほうが小さい場合
		} else if (inputQuantifiedDate < targetsQuantifiedDate) {
			
			// 引数の日付が対象の日付よりも前の日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "よりも前の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 引数の日付と対象の日付が同じ日付であることを表示
			System.out.println(inputDay.toString() + "は、" + targetsDay.toString() + "と同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：compareTwoDates
	*概要：二つの日付の前後関係を調べる
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void compareTwoDates (Day inputFirstDay, Day inputSecondDay) {
		
		// 引数の一つ目の日付を計算し比較可能な数値へ変更
		int inputFirstQuantifiedDate = calculateQuantifiedDate(inputFirstDay);
		// 引数の二つ目の日付を計算し比較可能な数値へ変更
		int inputSecondQuantifiedDate = calculateQuantifiedDate(inputSecondDay);
		
		// 二つの日付を比較し、一つ目の日付のほうが大きい場合
		if (inputFirstQuantifiedDate > inputSecondQuantifiedDate) {
			
			// 一つ目の日付が後の日付で二つ目の日付が前の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が後の日付で、" + inputSecondDay.toString() + "が前の日付です。");
			
		// 二つの日付を比較し、二つ目の日付のほうが大きい場合
		} else if (inputFirstQuantifiedDate < inputSecondQuantifiedDate) {
			
			// 一つ目の日付が前の日付で二つ目の日付が後の日付であることを表示
			System.out.println(inputFirstDay.toString() + "が前の日付で、" + inputSecondDay.toString() + "が後の日付です。");
			
		// 二つの日付を比較し、二つとも同じ大きさの場合
		} else {
			
			// 二つの日付が同じ日付であることを表示
			System.out.println(inputFirstDay.toString() + "と" + inputSecondDay.toString() + "は同じ日付です。");
			
		}
		
	}
	
	/*
	*関数名：calculateTomorrow
	*概要：引数の日付の次の日の日付を返却
	*引数：日付(Day型)
	*戻り値：次の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateTomorrow (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearTomorrow = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthTomorrow = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateTomorrow = inputDay.date;
		
		// 次の日の日付の日の値を1つ進める
		++dateTomorrow;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateTomorrow > findMaximumDaysOfMonth(yearTomorrow, monthTomorrow)) {
			
			// 次の日の日付の日の値を最小値に戻す
			dateTomorrow = MINIMUM_DATE;
			// 次の日の日付の月の値を1つ進める
			++monthTomorrow;
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthTomorrow > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthTomorrow = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearTomorrow;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearTomorrow, monthTomorrow, dateTomorrow);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：moveTomorrow
	*概要：引数の日付の次の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveTomorrow (Day inputDay) {
		
		// 引数の日付の次の日の日付を表示
		System.out.println("明日の日付：" + calculateTomorrow(inputDay).toString());
		
	}
	
	/*
	*関数名：calculateSeveralDaysLater
	*概要：引数の日付の数日後の日付を返却
	*引数：日付(Day型)
	*戻り値：数日後の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static Day calculateSeveralDaysLater (Day inputDay) {
		
		// 次の日の日付の年の値を引数の日付の年の値で初期化
		int yearSeveralDaysLater = inputDay.year;
		// 次の日の日付の月の値を引数の日付の月の値で初期化
		int monthSeveralDaysLater = inputDay.month;
		// 次の日の日付の日の値を引数の日付の日の値で初期化
		int dateSeveralDaysLater = inputDay.date;
		
		System.out.print("何日後(有効範囲…1日以上)：");
		int shiftNumberOfDays = standardInput.nextInt();
		while (shiftNumberOfDays <= 0) {
			
			shiftNumberOfDays = inputRange();
			
		}
		
		if (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date >= shiftNumberOfDays) {
			
			dateSeveralDaysLater += shiftNumberOfDays;
			
		} else {
			
			do {
				
				shiftNumberOfDays -= (findMaximumDaysOfMonth(inputDay.year, inputDay.month) - inputDay.date);
				monthSeveralDaysLater++;
				
			} (shiftNumberOfDays < 0)
			
		}
		
		// 次の日の日付の日の値を1つ進める
		dateSeveralDaysLater += shiftNumberOfDays;
		
		// 次の日の日付の日の値がその月の最大日数を超える場合
		if (dateSeveralDaysLater > findMaximumDaysOfMonth(yearSeveralDaysLater, monthSeveralDaysLater)) {
			
			// 次の日の日付の月の値を1つ進める
			++monthSeveralDaysLater;
			// 次の日の日付の日の値を最小値に戻す
			dateSeveralDaysLater = MINIMUM_DATE;

			
			
			// 次の日の日付の月の値が最大月数を超える場合
			if (monthSeveralDaysLater > MAXIMUM_MONTH) {
				
				// 次の日の日付の月の値を最小値に戻す
				monthSeveralDaysLater = MINIMUM_MONTH;
				// 次の日の日付の年の値を1つ進める
				++yearSeveralDaysLater;
				
			}
			
		}
		
		// 次の日の日付を求めた値で初期化
		Day nextDay = new Day(yearSeveralDaysLater, monthSeveralDaysLater, dateSeveralDaysLater);
		
		// 次の日の日付を返却
		return nextDay;
		
	}
	
	/*
	*関数名：calculateYesterday
	*概要：引数の日付の前の日の日付を返却
	*引数：日付(Day型)
	*戻り値：前の日の日付(Day型)
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/

	public static Day calculateYesterday (Day inputDay) {
		
		// 前の日の日付の年の値を引数の日付の年の値で初期化
		int yearYesterday = inputDay.year;
		// 前の日の日付の月の値を引数の日付の月の値で初期化
		int monthYesterday = inputDay.month;
		// 前の日の日付の日の値を引数の日付の日の値で初期化
		int dateYesterday = inputDay.date;
		
		// 引数の日付の各値すべてがそれぞれの最小値だった場合
		if (inputDay.year == MINIMUM_YEAR && inputDay.month == MINIMUM_MONTH || inputDay.date == MINIMUM_DATE) {
			
			// これ以上前日に戻せないことを表示
			System.out.println("これ以上前日に戻せません。");
			
		// 引数の日付の各値がどれか一つでも最小値でなかった場合
		} else {
		
			// 前の日の日付の日の値を1つ戻す
			--dateYesterday;
			
			// 前の日の日付の日の値が最小値を下回る場合
			if (dateYesterday < MINIMUM_DATE) {
				
				// 前の日の日付の月の値を1つ戻す
				--monthYesterday;
				
				// 前の日の日付の月の値が最小値を下回る場合
				if (monthYesterday < MINIMUM_MONTH) {
					
					// 前の日の日付の年の値を1つ戻す
					--yearYesterday;
					// 前の日の日付の月の値を最大値に進める
					monthYesterday = MAXIMUM_MONTH;
					
				}
				
				// 前の日の日付の日の値をその月の最大日数に進める
				dateYesterday = findMaximumDaysOfMonth(yearYesterday, monthYesterday);
				
			}
			
		}
		
		// 前の日の日付を求めた値で初期化
		Day beforeDay = new Day(yearYesterday, monthYesterday, dateYesterday);
		
		// 前の日の日付を返却
		return beforeDay;
		
	}
	
	/*
	*関数名：moveYesterday
	*概要：引数の日付の前の日の日付を表示
	*引数：日付(Day型)
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/15
	*/
	
	public static void moveYesterday (Day inputDay) {
		
		// 引数の日付の前の日の日付を表示
		System.out.println("昨日の日付：" + calculateYesterday(inputDay).toString());
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-05-15 14:49:23.439
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-05-15 14:49:23.439
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-15 16:55:48.756
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 2 2 2024-05-15 19:40:23.374
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2024-05-16 10:38:01.238 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.lsp4e 2 0 2024-05-16 11:47:42.944
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-16 15:48:53.188
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 4 4 2024-05-16 17:04:43.547
!MESSAGE Could not create action delegate for id: org.springsource.ide.eclipse.commons.launch.stop.action
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2024-05-16 17:04:43.547
!MESSAGE プラグイン "org.springsource.ide.eclipse.commons.ui" は、クラス "org.springsource.ide.eclipse.commons.ui.launch.StopProcessPullDownToolbarDelegate" をインスタンス化できませんでした。
!STACK 0
java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.WorkbenchPlugin.lambda$0(WorkbenchPlugin.java:287)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPlugin.createExtension(WorkbenchPlugin.java:285)
	at org.eclipse.ui.internal.PluginAction.createDelegate(PluginAction.java:126)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:214)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:218)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$5(ActionContributionItem.java:453)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.<init>(LaunchList.java:74)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.<init>(LiveProcessTracker.java:49)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.getInstance(LiveProcessTracker.java:43)
	at org.springsource.ide.eclipse.commons.ui.launch.StopProcessPullDownToolbarDelegate.createList(StopProcessPullDownToolbarDelegate.java:34)
	at org.springsource.ide.eclipse.commons.ui.launch.AbstractLaunchToolbarPulldown.<init>(AbstractLaunchToolbarPulldown.java:52)
	at org.springsource.ide.eclipse.commons.ui.launch.StopProcessPullDownToolbarDelegate.<init>(StopProcessPullDownToolbarDelegate.java:18)
	... 43 more
Root exception:
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.<init>(LaunchList.java:74)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.<init>(LiveProcessTracker.java:49)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.getInstance(LiveProcessTracker.java:43)
	at org.springsource.ide.eclipse.commons.ui.launch.StopProcessPullDownToolbarDelegate.createList(StopProcessPullDownToolbarDelegate.java:34)
	at org.springsource.ide.eclipse.commons.ui.launch.AbstractLaunchToolbarPulldown.<init>(AbstractLaunchToolbarPulldown.java:52)
	at org.springsource.ide.eclipse.commons.ui.launch.StopProcessPullDownToolbarDelegate.<init>(StopProcessPullDownToolbarDelegate.java:18)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.WorkbenchPlugin.lambda$0(WorkbenchPlugin.java:287)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPlugin.createExtension(WorkbenchPlugin.java:285)
	at org.eclipse.ui.internal.PluginAction.createDelegate(PluginAction.java:126)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:214)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:218)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$5(ActionContributionItem.java:453)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 4 2024-05-16 17:04:43.671
!MESSAGE Could not create action delegate for id: org.springsource.ide.eclipse.commons.launch.relaunch.action
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2024-05-16 17:04:43.672
!MESSAGE プラグイン "org.springsource.ide.eclipse.commons.ui" は、クラス "org.springsource.ide.eclipse.commons.ui.launch.RelaunchProcessPullDownToolbarDelegate" をインスタンス化できませんでした。
!STACK 0
java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.WorkbenchPlugin.createExtension(WorkbenchPlugin.java:281)
	at org.eclipse.ui.internal.PluginAction.createDelegate(PluginAction.java:126)
	at org.eclipse.ui.internal.WWinPluginAction.refreshActionList(WWinPluginAction.java:157)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:394)
	at org.eclipse.jface.dialogs.MessageDialog.openInformation(MessageDialog.java:491)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:216)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:218)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$5(ActionContributionItem.java:453)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.<init>(LaunchList.java:74)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.<init>(LiveAndDeadProcessTracker.java:77)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.getInstance(LiveAndDeadProcessTracker.java:69)
	at org.springsource.ide.eclipse.commons.ui.launch.RelaunchProcessPullDownToolbarDelegate.createList(RelaunchProcessPullDownToolbarDelegate.java:29)
	at org.springsource.ide.eclipse.commons.ui.launch.AbstractLaunchToolbarPulldown.<init>(AbstractLaunchToolbarPulldown.java:52)
	at org.springsource.ide.eclipse.commons.ui.launch.RelaunchProcessPullDownToolbarDelegate.<init>(RelaunchProcessPullDownToolbarDelegate.java:15)
	... 50 more
Root exception:
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.<init>(LaunchList.java:74)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.<init>(LiveAndDeadProcessTracker.java:77)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.getInstance(LiveAndDeadProcessTracker.java:69)
	at org.springsource.ide.eclipse.commons.ui.launch.RelaunchProcessPullDownToolbarDelegate.createList(RelaunchProcessPullDownToolbarDelegate.java:29)
	at org.springsource.ide.eclipse.commons.ui.launch.AbstractLaunchToolbarPulldown.<init>(AbstractLaunchToolbarPulldown.java:52)
	at org.springsource.ide.eclipse.commons.ui.launch.RelaunchProcessPullDownToolbarDelegate.<init>(RelaunchProcessPullDownToolbarDelegate.java:15)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.WorkbenchPlugin.createExtension(WorkbenchPlugin.java:281)
	at org.eclipse.ui.internal.PluginAction.createDelegate(PluginAction.java:126)
	at org.eclipse.ui.internal.WWinPluginAction.refreshActionList(WWinPluginAction.java:157)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:394)
	at org.eclipse.jface.dialogs.MessageDialog.openInformation(MessageDialog.java:491)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:216)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:218)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$5(ActionContributionItem.java:453)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:05:08.506
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:05:08.507
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:05:09.218
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:05:09.219
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:05:09.219
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:05:09.221
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:06:30.781
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:06:30.783
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:06:30.784
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:06:30.785
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:06:30.790
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:06:30.792
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:08:06.321
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:08:06.322
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:08:14.962
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:08:14.962
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:08:14.963
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:08:14.964
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:08:59.220
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:08:59.221
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:08:59.531
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:08:59.532
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:08:59.532
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:08:59.533
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:12:15.413
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:12:15.414
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:12:16.604
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:12:16.604
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:12:16.607
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:12:16.607
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:13:06.731
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:13:06.733
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:17:29.496
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:17:29.497
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:17:29.497
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:17:29.498
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:19:01.557
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:19:01.558
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:19:01.569
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:19:01.570
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:19:01.571
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:19:01.573
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:21:05.293
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:21:05.294
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:22:20.942
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:22:20.943
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:22:20.943
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:22:20.944
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:22:38.354
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:22:38.357
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:23:35.839
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:23:35.840
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:23:35.840
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:23:35.841
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:26:06.542
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:26:06.542
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:39:22.247
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:39:22.247
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:39:22.248
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:39:22.249
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:39:36.403
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:39:36.404
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:40:42.652
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:40:42.652
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:40:42.652
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:40:42.653
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:42:14.242
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:42:14.244
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:50:30.918
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:50:30.918
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:50:30.918
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:50:30.920
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 17:51:27.592
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 17:51:27.592
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 18:10:09.342
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 18:10:09.343
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 18:10:09.344
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 18:10:09.344
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 18:10:26.852
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 18:10:26.852
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 18:10:40.378
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 18:10:40.378
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 18:10:40.379
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 18:10:40.379
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 18:11:41.149
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 18:11:41.149
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 18:11:41.361
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 18:11:41.362
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 18:11:41.363
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 18:11:41.364
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 18:15:25.244
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 18:15:25.245
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:15:09.276
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:15:09.276
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:15:09.277
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:15:09.278
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:16:00.989
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:16:00.990
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:16:00.990
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:16:00.991
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:16:01.000
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:16:01.003
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:16:11.688
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:16:11.689
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:17:19.366
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:17:19.367
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:17:19.368
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:17:19.368
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:17:41.206
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:17:41.206
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:19:11.414
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:19:11.415
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:19:11.415
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:19:11.416
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:20:35.888
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:20:35.889
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:20:35.891
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:20:35.895
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:20:35.898
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:20:35.899
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:24:34.863
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:24:34.863
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:48:34.057
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:48:34.058
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 19:48:34.059
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 19:48:34.060
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 20:02:09.203
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 20:02:09.203
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 20:02:09.214
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 20:02:09.215
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 20:02:09.216
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 20:02:09.216
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 20:03:43.781
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 20:03:43.781
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 20:03:43.867
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 20:03:43.868
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 20:03:43.869
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 20:03:43.869
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 20:03:58.938
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 20:03:58.938
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 20:04:05.203
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 20:04:05.203
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 20:04:05.204
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 20:04:05.205
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-16 20:04:13.699
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-16 20:04:13.700
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui 2 2 2024-05-16 20:04:21.072
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2024-05-17 09:37:25.928 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-17 10:57:33.215
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.814
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.815
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.837
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.838
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.839
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.840
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.841
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.841
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.844
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.844
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.873
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 15:59:00.874
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/Circle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 16:44:48.621
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/id/RandId.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 16:44:48.622
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/id/RandId.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 16:44:48.624
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/id/RandId.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 16:44:48.625
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/id/RandId.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 16:44:48.642
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/id/RandId.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-17 16:44:48.643
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap11/id/RandId.java' が存在しません。
!SESSION 2024-05-20 10:08:42.123 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-20 10:09:48.912
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-20 10:21:51.982
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-05-20 11:41:42.794 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-20 11:49:38.409
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-20 15:13:24.595
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-20 15:54:12.378
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-20 15:54:15.014
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-20 16:19:42.029
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-20 17:23:47.194
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-20 17:35:41.131
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-20 18:03:00.955
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap12.car;

/*
*クラス名：CarMileageTester
*概要：CarMileageTesterクラスのテスト
*作成者：N.Kimoto
*作成日：2024/05/
*/


// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class CarMileageTester {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値(int型)
	*戻り値：再入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange(int inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}

	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値(double型)
	*戻り値：再入力された値(double型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static double inputRange(double inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextDouble();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}

	/*
	*関数名：main
	*概要：車のデータを管理し表示させ、必要に応じて移動する
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/20
	*/
	
	public static void main(String[] args) {

		// 車の各種データの入力を促す
		System.out.println("車のデータを入力せよ。");
		
		// 車の名前の入力を促す
		System.out.print("名前は：");
		// 入力された値を読み込む
		String name = standardInput.next();
		// 車幅の入力を促す
		System.out.print("車幅は：");
		// 入力された値を読み込む
		int width = standardInput.nextInt();
		// 0以下の値が入力された場合
		 (width <= 0) {
			
			// 正の整数値で入力させる
			width = inputRange(width);
			
		}
		// 車高の入力を促す
		System.out.print("高さは：");
		// 入力された値を読み込む
		int height = standardInput.nextInt();
		// 0以下の値が入力された場合
		if (height <= 0) {
			
			// 正の整数値で入力させる
			height = inputRange(height);
			
		}
		// 車長の入力を促す
		System.out.print("長さは：");
		// 入力された値を読み込む
		int length = standardInput.nextInt();
		// 0以下の値が入力された場合
		if (length <= 0) {
			
			// 正の整数値で入力させる
			length = inputRange(length);
			
		}
		// ガソリン量の入力を促す
		System.out.print("ガソリン量は：");
		// 入力された値を読み込む
		double fuel = standardInput.nextDouble();
		// 0以下の値が入力された場合
		if (fuel <= 0) {
			
			// 正の実数値で入力させる
			fuel = inputRange(fuel);
			
		}
		// 購入日の日付の年の値の入力を促す
		System.out.print("購入日の年：");
		// 入力された値を読み込む
		int purchaseDayYear = standardInput.nextInt();
		// 購入日の日付の月の値の入力を促す
		System.out.print("購入日の月：");
		// 入力された値を読み込む
		int purchaseDayMonth = standardInput.nextInt();
		// 購入日の日付の日の値の入力を促す
		System.out.print("購入日の日：");
		// 入力された値を読み込む
		int purchaseDayDate = standardInput.nextInt();
		// 入力された値で購入日を初期化
		Day purchaseDay = new Day(purchaseDayYear, purchaseDayMonth, purchaseDayDate);
		
		// 入力された情報で車のデータを初期化
		CarMileage myCar = new CarMileage(name, width, height, length, fuel, purchaseDay);
		// 車のデータを表示
		System.out.println(myCar.toString());
		
		// 移動できる燃料が残っている場合
		while (true) {
			
			// 現在地・残り燃料・総走行距離を表示
			System.out.println("現在地(" + myCar.getX() + "km, " + myCar.getY() 
			+ "km)・残り燃料 "+ myCar.getFuel() + "L・総走行距離：" + myCar.getTotalMileage());
			// 移動するかどうかの入力を促す
			System.out.print("移動しますか[0…No / 1…Yes]：");
			// 移動しない意思を表す定数を宣言
			final int CHOOSE_STOPING = 0;
			// 移動する意思を表す定数を宣言
			final int CHOOSE_MOVING = 1;
			// 入力された値を読み込む
			int inputJudgment = standardInput.nextInt();
			// 0と1以外の値が入力された場合
			if (inputJudgment != CHOOSE_STOPING && inputJudgment != CHOOSE_MOVING) {
				
				// 0か1を入力させる
				inputJudgment = inputRange(inputJudgment);
				
			}
			
			// 0を入力した場合
			if (inputJudgment == CHOOSE_STOPING) {
				
				// 移動を終了する
				break;
				
			}
			
			// X方向の移動距離の入力を促す
			System.out.print("X方向の移動距離：");
			// 入力された値を読み込む
			double dx = standardInput.nextDouble();
			// Y方向の移動距離の入力を促す
			System.out.print("Y方向の移動距離：");
			// 入力された値を読み込む
			double dy = standardInput.nextDouble();
			// 総走行距離を計算する
			CarMileage.addTotalMileage(dx, dy);
			
			// 移動するのに燃料が不足している場合
			if (!myCar.move(dx, dy)) {
				
				// 燃料が不足しており移動できないことを表示
				System.out.println("燃料が足りません！");
				
			}
			
			
			
		}

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-05-20 18:03:00.956
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-05-20 18:03:00.957
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-20 18:03:01.151
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap12.car;

/*
*クラス名：CarMileageTester
*概要：CarMileageTesterクラスのテスト
*作成者：N.Kimoto
*作成日：2024/05/
*/


// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class CarMileageTester {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値(int型)
	*戻り値：再入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange(int inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}

	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値(double型)
	*戻り値：再入力された値(double型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static double inputRange(double inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextDouble();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}

	/*
	*関数名：main
	*概要：車のデータを管理し表示させ、必要に応じて移動する
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/20
	*/
	
	public static void main(String[] args) {

		// 車の各種データの入力を促す
		System.out.println("車のデータを入力せよ。");
		
		// 車の名前の入力を促す
		System.out.print("名前は：");
		// 入力された値を読み込む
		String name = standardInput.next();
		// 車幅の入力を促す
		System.out.print("車幅は：");
		// 入力された値を読み込む
		int width = standardInput.nextInt();
		// 0以下の値が入力された場合
		 (width <= 0) {
			
			// 正の整数値で入力させる
			width = inputRange(width);
			
		}
		// 車高の入力を促す
		System.out.print("高さは：");
		// 入力された値を読み込む
		int height = standardInput.nextInt();
		// 0以下の値が入力された場合
		if (height <= 0) {
			
			// 正の整数値で入力させる
			height = inputRange(height);
			
		}
		// 車長の入力を促す
		System.out.print("長さは：");
		// 入力された値を読み込む
		int length = standardInput.nextInt();
		// 0以下の値が入力された場合
		if (length <= 0) {
			
			// 正の整数値で入力させる
			length = inputRange(length);
			
		}
		// ガソリン量の入力を促す
		System.out.print("ガソリン量は：");
		// 入力された値を読み込む
		double fuel = standardInput.nextDouble();
		// 0以下の値が入力された場合
		if (fuel <= 0) {
			
			// 正の実数値で入力させる
			fuel = inputRange(fuel);
			
		}
		// 購入日の日付の年の値の入力を促す
		System.out.print("購入日の年：");
		// 入力された値を読み込む
		int purchaseDayYear = standardInput.nextInt();
		// 購入日の日付の月の値の入力を促す
		System.out.print("購入日の月：");
		// 入力された値を読み込む
		int purchaseDayMonth = standardInput.nextInt();
		// 購入日の日付の日の値の入力を促す
		System.out.print("購入日の日：");
		// 入力された値を読み込む
		int purchaseDayDate = standardInput.nextInt();
		// 入力された値で購入日を初期化
		Day purchaseDay = new Day(purchaseDayYear, purchaseDayMonth, purchaseDayDate);
		
		// 入力された情報で車のデータを初期化
		CarMileage myCar = new CarMileage(name, width, height, length, fuel, purchaseDay);
		// 車のデータを表示
		System.out.println(myCar.toString());
		
		// 移動できる燃料が残っている場合
		while (true) {
			
			// 現在地・残り燃料・総走行距離を表示
			System.out.println("現在地(" + myCar.getX() + "km, " + myCar.getY() 
			+ "km)・残り燃料 "+ myCar.getFuel() + "L・総走行距離：" + myCar.getTotalMileage());
			// 移動するかどうかの入力を促す
			System.out.print("移動しますか[0…No / 1…Yes]：");
			// 移動しない意思を表す定数を宣言
			final int CHOOSE_STOPING = 0;
			// 移動する意思を表す定数を宣言
			final int CHOOSE_MOVING = 1;
			// 入力された値を読み込む
			int inputJudgment = standardInput.nextInt();
			// 0と1以外の値が入力された場合
			if (inputJudgment != CHOOSE_STOPING && inputJudgment != CHOOSE_MOVING) {
				
				// 0か1を入力させる
				inputJudgment = inputRange(inputJudgment);
				
			}
			
			// 0を入力した場合
			if (inputJudgment == CHOOSE_STOPING) {
				
				// 移動を終了する
				break;
				
			}
			
			// X方向の移動距離の入力を促す
			System.out.print("X方向の移動距離：");
			// 入力された値を読み込む
			double dx = standardInput.nextDouble();
			// Y方向の移動距離の入力を促す
			System.out.print("Y方向の移動距離：");
			// 入力された値を読み込む
			double dy = standardInput.nextDouble();
			// 総走行距離を計算する
			CarMileage.addTotalMileage(dx, dy);
			
			// 移動するのに燃料が不足している場合
			if (!myCar.move(dx, dy)) {
				
				// 燃料が不足しており移動できないことを表示
				System.out.println("燃料が足りません！");
				
			}
			
			
			
		}

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-05-20 18:03:01.154
!MESSAGE プラグイン "org.eclipse.jdt.core.manipulation" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-05-20 18:03:01.156
!MESSAGE AST 作成中に JDT コアでエラー
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-05-20 18:03:14.477
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package MeikaiJava.Chap12.car;

/*
*クラス名：CarMileageTester
*概要：CarMileageTesterクラスのテスト
*作成者：N.Kimoto
*作成日：2024/05/
*/


// Javaでキーボードから標準入力を取得するために必要なScannerクラスをインポート
import java.util.Scanner;

public class CarMileageTester {
	
	// Scannerオブジェクトを生成
	static Scanner standardInput = new Scanner(System.in);
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値(int型)
	*戻り値：再入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange(int inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}

	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：入力された値(double型)
	*戻り値：再入力された値(double型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static double inputRange(double inputValue) {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		inputValue = standardInput.nextDouble();
		// 読み込んだ値を返却する
		return inputValue;

	}
	
	/*
	*関数名：inputRange
	*概要：入力した値を範囲内の値で入力させる
	*引数：なし
	*戻り値：入力された値(int型)
	*作成者：N.Kimoto
	*作成日：2024/04/30
	*/
	
	static int inputRange() {

		// 範囲内の値の入力を促す
		System.out.print("有効範囲内で入力してください：");
		// 入力された値を読み込む
		int inputValue = standardInput.nextInt();
		// 読み込んだ値を返却する
		return inputValue;

	}

	/*
	*関数名：main
	*概要：車のデータを管理し表示させ、必要に応じて移動する
	*引数：なし
	*戻り値：なし
	*作成者：N.Kimoto
	*作成日：2024/05/20
	*/
	
	public static void main(String[] args) {

		// 車の各種データの入力を促す
		System.out.println("車のデータを入力せよ。");
		
		// 車の名前の入力を促す
		System.out.print("名前は：");
		// 入力された値を読み込む
		String name = standardInput.next();
		// 車幅の入力を促す
		System.out.print("車幅は：");
		// 入力された値を読み込む
		int width = standardInput.nextInt();
		// 0以下の値が入力された場合
		while (width <= 0) {
			
			// 正の整数値で入力させる
			width = inputRange(width);
			
		}
		// 車高の入力を促す
		System.out.print("高さは：");
		// 入力された値を読み込む
		int height = standardInput.nextInt();
		// 0以下の値が入力された場合
		while (height <= 0) {
			
			// 正の整数値で入力させる
			height = inputRange(height);
			
		}
		// 車長の入力を促す
		System.out.print("長さは：");
		// 入力された値を読み込む
		int length = standardInput.nextInt();
		// 0以下の値が入力された場合
		 (length <= 0) {
			
			// 正の整数値で入力させる
			length = inputRange(length);
			
		}
		// ガソリン量の入力を促す
		System.out.print("ガソリン量は：");
		// 入力された値を読み込む
		double fuel = standardInput.nextDouble();
		// 0以下の値が入力された場合
		if (fuel <= 0) {
			
			// 正の実数値で入力させる
			fuel = inputRange(fuel);
			
		}
		// 購入日の日付の年の値の入力を促す
		System.out.print("購入日の年：");
		// 入力された値を読み込む
		int purchaseDayYear = standardInput.nextInt();
		// 購入日の日付の月の値の入力を促す
		System.out.print("購入日の月：");
		// 入力された値を読み込む
		int purchaseDayMonth = standardInput.nextInt();
		// 購入日の日付の日の値の入力を促す
		System.out.print("購入日の日：");
		// 入力された値を読み込む
		int purchaseDayDate = standardInput.nextInt();
		// 入力された値で購入日を初期化
		Day purchaseDay = new Day(purchaseDayYear, purchaseDayMonth, purchaseDayDate);
		
		// 入力された情報で車のデータを初期化
		CarMileage myCar = new CarMileage(name, width, height, length, fuel, purchaseDay);
		// 車のデータを表示
		System.out.println(myCar.toString());
		
		// 移動できる燃料が残っている場合
		while (true) {
			
			// 現在地・残り燃料・総走行距離を表示
			System.out.println("現在地(" + myCar.getX() + "km, " + myCar.getY() 
			+ "km)・残り燃料 "+ myCar.getFuel() + "L・総走行距離：" + myCar.getTotalMileage());
			// 移動するかどうかの入力を促す
			System.out.print("移動しますか[0…No / 1…Yes]：");
			// 移動しない意思を表す定数を宣言
			final int CHOOSE_STOPING = 0;
			// 移動する意思を表す定数を宣言
			final int CHOOSE_MOVING = 1;
			// 入力された値を読み込む
			int inputJudgment = standardInput.nextInt();
			// 0と1以外の値が入力された場合
			if (inputJudgment != CHOOSE_STOPING && inputJudgment != CHOOSE_MOVING) {
				
				// 0か1を入力させる
				inputJudgment = inputRange(inputJudgment);
				
			}
			
			// 0を入力した場合
			if (inputJudgment == CHOOSE_STOPING) {
				
				// 移動を終了する
				break;
				
			}
			
			// X方向の移動距離の入力を促す
			System.out.print("X方向の移動距離：");
			// 入力された値を読み込む
			double dx = standardInput.nextDouble();
			// Y方向の移動距離の入力を促す
			System.out.print("Y方向の移動距離：");
			// 入力された値を読み込む
			double dy = standardInput.nextDouble();
			// 総走行距離を計算する
			CarMileage.addTotalMileage(dx, dy);
			
			// 移動するのに燃料が不足している場合
			if (!myCar.move(dx, dy)) {
				
				// 燃料が不足しており移動できないことを表示
				System.out.println("燃料が足りません！");
				
			}
			
			
			
		}

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-05-20 18:03:14.479
!MESSAGE プラグイン "org.eclipse.jdt.ui" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-05-20 18:03:14.479
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SESSION 2024-05-21 09:52:21.183 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-21 11:02:02.698
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-21 11:05:00.267
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-21 11:05:01.773
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-21 11:10:30.039
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY mergedoc.encoding 2 0 2024-05-21 11:20:31.279
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap12/pet/PetTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 11:20:31.279
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap12/pet/PetTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 11:20:31.281
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap12/pet/PetTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 11:20:31.282
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap12/pet/PetTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 11:20:31.283
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap12/pet/PetTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 11:20:31.284
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap12/pet/PetTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 11:20:31.286
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap12/pet/PetTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 11:20:31.287
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap12/pet/PetTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 11:20:31.310
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap12/pet/PetTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 11:20:31.310
!MESSAGE リソース '/test/src/MeikaiJava/List/Chap12/pet/PetTester.java' が存在しません。

!ENTRY org.eclipse.lsp4e 2 0 2024-05-21 11:37:18.118
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-21 13:19:04.053
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-21 14:42:25.452
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY mergedoc.encoding 2 0 2024-05-21 15:24:24.263
!MESSAGE リソース '/test/src/MeikaiJava/Chap12/timeAccount/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 15:24:24.264
!MESSAGE リソース '/test/src/MeikaiJava/Chap12/timeAccount/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 15:24:24.265
!MESSAGE リソース '/test/src/MeikaiJava/Chap12/timeAccount/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 15:24:24.266
!MESSAGE リソース '/test/src/MeikaiJava/Chap12/timeAccount/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 15:24:24.267
!MESSAGE リソース '/test/src/MeikaiJava/Chap12/timeAccount/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 15:24:24.268
!MESSAGE リソース '/test/src/MeikaiJava/Chap12/timeAccount/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 15:24:24.271
!MESSAGE リソース '/test/src/MeikaiJava/Chap12/timeAccount/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 15:24:24.272
!MESSAGE リソース '/test/src/MeikaiJava/Chap12/timeAccount/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 15:24:24.319
!MESSAGE リソース '/test/src/MeikaiJava/Chap12/timeAccount/AccountTester.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-21 15:24:24.320
!MESSAGE リソース '/test/src/MeikaiJava/Chap12/timeAccount/AccountTester.java' が存在しません。
!SESSION 2024-05-22 09:37:58.130 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-22 09:38:35.687
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-22 11:17:03.895
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:05:15.793
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/Triangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:05:15.794
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/Triangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:05:15.796
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/Triangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:05:15.797
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/Triangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:05:15.798
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/Triangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:05:15.798
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/Triangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:05:15.800
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/Triangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:05:15.801
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/Triangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:05:15.845
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/Triangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:05:15.845
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/Triangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:12:37.713
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/AbsTriangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:12:37.714
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/AbsTriangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:12:37.717
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/AbsTriangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:12:37.718
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/AbsTriangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:12:37.720
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/AbsTriangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:12:37.721
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/AbsTriangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:12:37.727
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/AbsTriangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:12:37.727
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/AbsTriangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:12:37.779
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/AbsTriangle.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-22 16:12:37.780
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/shape2/AbsTriangle.java' が存在しません。

!ENTRY org.eclipse.lsp4e 2 0 2024-05-22 16:28:54.930
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-22 16:45:18.131
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-05-23 09:49:55.417 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-23 10:01:19.903
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.181
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.181
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.220
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.221
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.222
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.223
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.223
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.224
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.226
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.226
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.247
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY mergedoc.encoding 2 0 2024-05-23 10:08:53.248
!MESSAGE リソース '/test/src/MeikaiJava/Chap13/rockPaperScissors/RockPaperScissors.java' が存在しません。

!ENTRY org.eclipse.lsp4e 2 0 2024-05-23 13:59:39.460
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-23 15:39:47.691
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-05-24 10:08:53.956 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ja_JP
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ui 2 2 2024-05-24 10:09:49.768
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-24 11:35:35.458
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 4 4 2024-05-24 15:13:42.350
!MESSAGE Could not create action delegate for id: org.springsource.ide.eclipse.commons.launch.stop.action
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2024-05-24 15:13:42.350
!MESSAGE プラグイン "org.springsource.ide.eclipse.commons.ui" は、クラス "org.springsource.ide.eclipse.commons.ui.launch.StopProcessPullDownToolbarDelegate" をインスタンス化できませんでした。
!STACK 0
java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.WorkbenchPlugin.lambda$0(WorkbenchPlugin.java:287)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPlugin.createExtension(WorkbenchPlugin.java:285)
	at org.eclipse.ui.internal.PluginAction.createDelegate(PluginAction.java:126)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:214)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:218)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$5(ActionContributionItem.java:453)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.<init>(LaunchList.java:74)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.<init>(LiveProcessTracker.java:49)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.getInstance(LiveProcessTracker.java:43)
	at org.springsource.ide.eclipse.commons.ui.launch.StopProcessPullDownToolbarDelegate.createList(StopProcessPullDownToolbarDelegate.java:34)
	at org.springsource.ide.eclipse.commons.ui.launch.AbstractLaunchToolbarPulldown.<init>(AbstractLaunchToolbarPulldown.java:52)
	at org.springsource.ide.eclipse.commons.ui.launch.StopProcessPullDownToolbarDelegate.<init>(StopProcessPullDownToolbarDelegate.java:18)
	... 43 more
Root exception:
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.<init>(LaunchList.java:74)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.<init>(LiveProcessTracker.java:49)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.getInstance(LiveProcessTracker.java:43)
	at org.springsource.ide.eclipse.commons.ui.launch.StopProcessPullDownToolbarDelegate.createList(StopProcessPullDownToolbarDelegate.java:34)
	at org.springsource.ide.eclipse.commons.ui.launch.AbstractLaunchToolbarPulldown.<init>(AbstractLaunchToolbarPulldown.java:52)
	at org.springsource.ide.eclipse.commons.ui.launch.StopProcessPullDownToolbarDelegate.<init>(StopProcessPullDownToolbarDelegate.java:18)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.WorkbenchPlugin.lambda$0(WorkbenchPlugin.java:287)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPlugin.createExtension(WorkbenchPlugin.java:285)
	at org.eclipse.ui.internal.PluginAction.createDelegate(PluginAction.java:126)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:214)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:218)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$5(ActionContributionItem.java:453)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 4 2024-05-24 15:13:42.432
!MESSAGE Could not create action delegate for id: org.springsource.ide.eclipse.commons.launch.relaunch.action
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2024-05-24 15:13:42.432
!MESSAGE プラグイン "org.springsource.ide.eclipse.commons.ui" は、クラス "org.springsource.ide.eclipse.commons.ui.launch.RelaunchProcessPullDownToolbarDelegate" をインスタンス化できませんでした。
!STACK 0
java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.WorkbenchPlugin.createExtension(WorkbenchPlugin.java:281)
	at org.eclipse.ui.internal.PluginAction.createDelegate(PluginAction.java:126)
	at org.eclipse.ui.internal.WWinPluginAction.refreshActionList(WWinPluginAction.java:157)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:394)
	at org.eclipse.jface.dialogs.MessageDialog.openInformation(MessageDialog.java:491)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:216)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:218)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$5(ActionContributionItem.java:453)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.<init>(LaunchList.java:74)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.<init>(LiveAndDeadProcessTracker.java:77)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.getInstance(LiveAndDeadProcessTracker.java:69)
	at org.springsource.ide.eclipse.commons.ui.launch.RelaunchProcessPullDownToolbarDelegate.createList(RelaunchProcessPullDownToolbarDelegate.java:29)
	at org.springsource.ide.eclipse.commons.ui.launch.AbstractLaunchToolbarPulldown.<init>(AbstractLaunchToolbarPulldown.java:52)
	at org.springsource.ide.eclipse.commons.ui.launch.RelaunchProcessPullDownToolbarDelegate.<init>(RelaunchProcessPullDownToolbarDelegate.java:15)
	... 50 more
Root exception:
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.<init>(LaunchList.java:74)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.<init>(LiveAndDeadProcessTracker.java:77)
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.getInstance(LiveAndDeadProcessTracker.java:69)
	at org.springsource.ide.eclipse.commons.ui.launch.RelaunchProcessPullDownToolbarDelegate.createList(RelaunchProcessPullDownToolbarDelegate.java:29)
	at org.springsource.ide.eclipse.commons.ui.launch.AbstractLaunchToolbarPulldown.<init>(AbstractLaunchToolbarPulldown.java:52)
	at org.springsource.ide.eclipse.commons.ui.launch.RelaunchProcessPullDownToolbarDelegate.<init>(RelaunchProcessPullDownToolbarDelegate.java:15)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.WorkbenchPlugin.createExtension(WorkbenchPlugin.java:281)
	at org.eclipse.ui.internal.PluginAction.createDelegate(PluginAction.java:126)
	at org.eclipse.ui.internal.WWinPluginAction.refreshActionList(WWinPluginAction.java:157)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:394)
	at org.eclipse.jface.dialogs.MessageDialog.openInformation(MessageDialog.java:491)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:216)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:218)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$5(ActionContributionItem.java:453)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:13:47.355
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:13:47.357
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2024-05-24 15:45:20.655
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:47:28.934
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:47:28.934
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:47:28.935
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:47:28.936
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:47:29.014
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:47:29.015
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:53:58.319
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:53:58.320
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:53:58.320
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:53:58.321
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:54:11.798
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:54:11.798
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:55:46.565
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:55:46.566
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:55:46.567
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:55:46.568
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:56:11.763
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:56:11.764
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:56:11.773
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:56:11.773
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:56:11.774
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:56:11.775
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:56:18.903
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:56:18.903
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:57:59.552
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:57:59.553
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:57:59.553
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:57:59.554
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:58:11.754
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:58:11.754
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:58:57.077
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:58:57.078
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.contains(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processCreated(LiveProcessTracker.java:75)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 15:58:57.079
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 15:58:57.079
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedHashMap.remove(Object)" because "this.configs" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveAndDeadProcessTracker.processCreated(LiveAndDeadProcessTracker.java:94)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:86)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 2 2024-05-24 16:11:48.057
!MESSAGE プラグイン "org.eclipse.debug.core" からのコードの起動で問題が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2024-05-24 16:11:48.058
!MESSAGE デバッグ・イベントのディスパッチ中に例外が発生しました。
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.LinkedList.remove(Object)" because "this.processes" is null
	at org.springsource.ide.eclipse.commons.ui.launch.LiveProcessTracker.processTerminated(LiveProcessTracker.java:64)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList.handleDebugEvent(LaunchList.java:91)
	at org.springsource.ide.eclipse.commons.ui.launch.LaunchList$1.handleDebugEvents(LaunchList.java:63)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:1214)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:1248)
	at org.eclipse.debug.core.DebugPlugin$EventDispatchJob.run(DebugPlugin.java:480)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
